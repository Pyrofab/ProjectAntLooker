<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JavaCV: Optical Flow Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JavaCV
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Optical Flow Algorithms</div>  </div>
</div><!--header-->
<div class="contents">

<p>Updates the motion history image by a moving silhouette.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.VariationalRefinement</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variational optical flow refinement. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.DISOpticalFlow</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">DIS optical flow algorithm. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac3566ed874933bad6b2825c00f37bfac"><td class="memItemLeft" align="right" valign="top"><a id="gac3566ed874933bad6b2825c00f37bfac"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSF</b> ( @ByVal Mat from, @ByVal Mat to, @ByVal Mat flow, int layers, int averaging_block_size, int max_flow)</td></tr>
<tr class="separator:gac3566ed874933bad6b2825c00f37bfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29dd3fec5011cf1d5c7fa051ff1c38ad"><td class="memItemLeft" align="right" valign="top"><a id="ga29dd3fec5011cf1d5c7fa051ff1c38ad"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSF</b> ( @ByVal UMat from, @ByVal UMat to, @ByVal UMat flow, int layers, int averaging_block_size, int max_flow)</td></tr>
<tr class="separator:ga29dd3fec5011cf1d5c7fa051ff1c38ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76902de70b538596bed7e39b7777384d"><td class="memItemLeft" align="right" valign="top">static native void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga76902de70b538596bed7e39b7777384d">org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSF</a> ( @ByVal Mat from, @ByVal Mat to, @ByVal Mat flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)</td></tr>
<tr class="memdesc:ga76902de70b538596bed7e39b7777384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate an optical flow using "SimpleFlow" algorithm.  <a href="#ga76902de70b538596bed7e39b7777384d">More...</a><br /></td></tr>
<tr class="separator:ga76902de70b538596bed7e39b7777384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf778fa8a2d9e5d336c9e66f1f6577271"><td class="memItemLeft" align="right" valign="top"><a id="gaf778fa8a2d9e5d336c9e66f1f6577271"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSF</b> ( @ByVal UMat from, @ByVal UMat to, @ByVal UMat flow, int layers, int averaging_block_size, int max_flow, double sigma_dist, double sigma_color, int postprocess_window, double sigma_dist_fix, double sigma_color_fix, double occ_thr, int upscale_averaging_radius, double upscale_sigma_dist, double upscale_sigma_color, double speed_up_thr)</td></tr>
<tr class="separator:gaf778fa8a2d9e5d336c9e66f1f6577271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab202f6c782e9356cf2a96620732785a9"><td class="memItemLeft" align="right" valign="top">static native void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gab202f6c782e9356cf2a96620732785a9">org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSparseToDense</a> ( @ByVal Mat from, @ByVal Mat to, @ByVal Mat flow, int grid_step, int k, float sigma, @Cast(&quot;bool&quot;) boolean use_post_proc, float fgs_lambda, float fgs_sigma)</td></tr>
<tr class="memdesc:gab202f6c782e9356cf2a96620732785a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast dense optical flow based on PyrLK sparse matches interpolation.  <a href="#gab202f6c782e9356cf2a96620732785a9">More...</a><br /></td></tr>
<tr class="separator:gab202f6c782e9356cf2a96620732785a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232800d9e04e7d3d9d6412b7bf695e11"><td class="memItemLeft" align="right" valign="top"><a id="ga232800d9e04e7d3d9d6412b7bf695e11"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSparseToDense</b> ( @ByVal Mat from, @ByVal Mat to, @ByVal Mat flow)</td></tr>
<tr class="separator:ga232800d9e04e7d3d9d6412b7bf695e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e7e5b5bb682863c28da8ee4375de834"><td class="memItemLeft" align="right" valign="top"><a id="ga1e7e5b5bb682863c28da8ee4375de834"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSparseToDense</b> ( @ByVal UMat from, @ByVal UMat to, @ByVal UMat flow, int grid_step, int k, float sigma, @Cast(&quot;bool&quot;) boolean use_post_proc, float fgs_lambda, float fgs_sigma)</td></tr>
<tr class="separator:ga1e7e5b5bb682863c28da8ee4375de834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1826bcce1245d87fd9fb9f65b508d1"><td class="memItemLeft" align="right" valign="top"><a id="gaad1826bcce1245d87fd9fb9f65b508d1"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSparseToDense</b> ( @ByVal UMat from, @ByVal UMat to, @ByVal UMat flow)</td></tr>
<tr class="separator:gaad1826bcce1245d87fd9fb9f65b508d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8adc9b054c1518ab41c20d8ada51b9b7"><td class="memItemLeft" align="right" valign="top">static native Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga8adc9b054c1518ab41c20d8ada51b9b7">org.bytedeco.javacpp.opencv_optflow.readOpticalFlow</a> ( @Str BytePointer path)</td></tr>
<tr class="memdesc:ga8adc9b054c1518ab41c20d8ada51b9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a .flo file.  <a href="#ga8adc9b054c1518ab41c20d8ada51b9b7">More...</a><br /></td></tr>
<tr class="separator:ga8adc9b054c1518ab41c20d8ada51b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2573f3c0a1dd3b91b11e315791bd2f"><td class="memItemLeft" align="right" valign="top"><a id="ga4b2573f3c0a1dd3b91b11e315791bd2f"></a>
static native Mat&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.readOpticalFlow</b> ( @Str String path)</td></tr>
<tr class="separator:ga4b2573f3c0a1dd3b91b11e315791bd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41bea8c25211f346782adfb40129e96e"><td class="memItemLeft" align="right" valign="top">static native boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga41bea8c25211f346782adfb40129e96e">org.bytedeco.javacpp.opencv_optflow.writeOpticalFlow</a> ( @Str BytePointer path, @ByVal Mat flow)</td></tr>
<tr class="memdesc:ga41bea8c25211f346782adfb40129e96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a .flo to disk.  <a href="#ga41bea8c25211f346782adfb40129e96e">More...</a><br /></td></tr>
<tr class="separator:ga41bea8c25211f346782adfb40129e96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce63b6527e15bb4e67e704210c41144"><td class="memItemLeft" align="right" valign="top"><a id="ga2ce63b6527e15bb4e67e704210c41144"></a>
static native boolean&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.writeOpticalFlow</b> ( @Str String path, @ByVal Mat flow)</td></tr>
<tr class="separator:ga2ce63b6527e15bb4e67e704210c41144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f16aacf0d7c356065b7051bc466fc9d"><td class="memItemLeft" align="right" valign="top"><a id="ga2f16aacf0d7c356065b7051bc466fc9d"></a>
static native boolean&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.writeOpticalFlow</b> ( @Str BytePointer path, @ByVal UMat flow)</td></tr>
<tr class="separator:ga2f16aacf0d7c356065b7051bc466fc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aaf6ebff608935e1cfe219216e8196b"><td class="memItemLeft" align="right" valign="top"><a id="ga1aaf6ebff608935e1cfe219216e8196b"></a>
static native boolean&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.writeOpticalFlow</b> ( @Str String path, @ByVal UMat flow)</td></tr>
<tr class="separator:ga1aaf6ebff608935e1cfe219216e8196b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7be52a57f2105050c7a7039ab1af2e"><td class="memItemLeft" align="right" valign="top"><a id="ga6d7be52a57f2105050c7a7039ab1af2e"></a>
static native VariationalRefinement&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga6d7be52a57f2105050c7a7039ab1af2e">org.bytedeco.javacpp.opencv_optflow.createVariationalFlowRefinement</a> ()</td></tr>
<tr class="memdesc:ga6d7be52a57f2105050c7a7039ab1af2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of VariationalRefinement. <br /></td></tr>
<tr class="separator:ga6d7be52a57f2105050c7a7039ab1af2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27f2a261b7f69f4eaaf2aa2552943a1a"><td class="memItemLeft" align="right" valign="top">static native DenseOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga27f2a261b7f69f4eaaf2aa2552943a1a">org.bytedeco.javacpp.opencv_optflow.createOptFlow_DeepFlow</a> ()</td></tr>
<tr class="memdesc:ga27f2a261b7f69f4eaaf2aa2552943a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">DeepFlow optical flow algorithm implementation.  <a href="#ga27f2a261b7f69f4eaaf2aa2552943a1a">More...</a><br /></td></tr>
<tr class="separator:ga27f2a261b7f69f4eaaf2aa2552943a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace52b781a9780c4c9a20951a2bec314d"><td class="memItemLeft" align="right" valign="top">static native DenseOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gace52b781a9780c4c9a20951a2bec314d">org.bytedeco.javacpp.opencv_optflow.createOptFlow_SimpleFlow</a> ()</td></tr>
<tr class="separator:gace52b781a9780c4c9a20951a2bec314d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd230cc626a64515ec35ac6c6c7fc099"><td class="memItemLeft" align="right" valign="top">static native DenseOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gabd230cc626a64515ec35ac6c6c7fc099">org.bytedeco.javacpp.opencv_optflow.createOptFlow_Farneback</a> ()</td></tr>
<tr class="separator:gabd230cc626a64515ec35ac6c6c7fc099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2033e98010d9ac8b150503a107601946"><td class="memItemLeft" align="right" valign="top">static native DenseOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga2033e98010d9ac8b150503a107601946">org.bytedeco.javacpp.opencv_optflow.createOptFlow_SparseToDense</a> ()</td></tr>
<tr class="separator:ga2033e98010d9ac8b150503a107601946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac107283f5dba4f320df3d9894aad537b"><td class="memItemLeft" align="right" valign="top">static native DISOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gac107283f5dba4f320df3d9894aad537b">org.bytedeco.javacpp.opencv_optflow.createOptFlow_DIS</a> (int preset)</td></tr>
<tr class="memdesc:gac107283f5dba4f320df3d9894aad537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of DISOpticalFlow.  <a href="#gac107283f5dba4f320df3d9894aad537b">More...</a><br /></td></tr>
<tr class="separator:gac107283f5dba4f320df3d9894aad537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c0f64b880a5a0a84db8ccf55ce4496"><td class="memItemLeft" align="right" valign="top"><a id="ga72c0f64b880a5a0a84db8ccf55ce4496"></a>
static native DISOpticalFlow&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.createOptFlow_DIS</b> ()</td></tr>
<tr class="separator:ga72c0f64b880a5a0a84db8ccf55ce4496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01b6daae8e4bd5db89270056d32f62f6"><td class="memItemLeft" align="right" valign="top"><a id="ga01b6daae8e4bd5db89270056d32f62f6"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.updateMotionHistory</b> ( @ByVal Mat silhouette, @ByVal Mat mhi, double timestamp, double duration)</td></tr>
<tr class="separator:ga01b6daae8e4bd5db89270056d32f62f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66502f64fc6246523b1b8c8ccf8f42fb"><td class="memItemLeft" align="right" valign="top"><a id="ga66502f64fc6246523b1b8c8ccf8f42fb"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.updateMotionHistory</b> ( @ByVal UMat silhouette, @ByVal UMat mhi, double timestamp, double duration)</td></tr>
<tr class="separator:ga66502f64fc6246523b1b8c8ccf8f42fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df8e7b81e72fc2df163a156ec07b5ed"><td class="memItemLeft" align="right" valign="top">static native void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#ga1df8e7b81e72fc2df163a156ec07b5ed">org.bytedeco.javacpp.opencv_optflow.calcMotionGradient</a> ( @ByVal Mat mhi, @ByVal Mat mask, @ByVal Mat orientation, double delta1, double delta2, int apertureSize)</td></tr>
<tr class="memdesc:ga1df8e7b81e72fc2df163a156ec07b5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a gradient orientation of a motion history image.  <a href="#ga1df8e7b81e72fc2df163a156ec07b5ed">More...</a><br /></td></tr>
<tr class="separator:ga1df8e7b81e72fc2df163a156ec07b5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4627dc7a9285cb61e098920781f78d9"><td class="memItemLeft" align="right" valign="top"><a id="gad4627dc7a9285cb61e098920781f78d9"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcMotionGradient</b> ( @ByVal Mat mhi, @ByVal Mat mask, @ByVal Mat orientation, double delta1, double delta2)</td></tr>
<tr class="separator:gad4627dc7a9285cb61e098920781f78d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ac164310092a6d2ecec7356e0bdd88d"><td class="memItemLeft" align="right" valign="top"><a id="ga6ac164310092a6d2ecec7356e0bdd88d"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcMotionGradient</b> ( @ByVal UMat mhi, @ByVal UMat mask, @ByVal UMat orientation, double delta1, double delta2, int apertureSize)</td></tr>
<tr class="separator:ga6ac164310092a6d2ecec7356e0bdd88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55f1d6817b88e79e4f9f46014b361ea0"><td class="memItemLeft" align="right" valign="top"><a id="ga55f1d6817b88e79e4f9f46014b361ea0"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcMotionGradient</b> ( @ByVal UMat mhi, @ByVal UMat mask, @ByVal UMat orientation, double delta1, double delta2)</td></tr>
<tr class="separator:ga55f1d6817b88e79e4f9f46014b361ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae09be23e6ebae54e6dad95914a82282d"><td class="memItemLeft" align="right" valign="top">static native double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gae09be23e6ebae54e6dad95914a82282d">org.bytedeco.javacpp.opencv_optflow.calcGlobalOrientation</a> ( @ByVal Mat orientation, @ByVal Mat mask, @ByVal Mat mhi, double timestamp, double duration)</td></tr>
<tr class="memdesc:gae09be23e6ebae54e6dad95914a82282d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a global motion orientation in a selected region.  <a href="#gae09be23e6ebae54e6dad95914a82282d">More...</a><br /></td></tr>
<tr class="separator:gae09be23e6ebae54e6dad95914a82282d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0fa162d7e97fc6d8d5c743eb9f7e76"><td class="memItemLeft" align="right" valign="top"><a id="ga2b0fa162d7e97fc6d8d5c743eb9f7e76"></a>
static native double&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.calcGlobalOrientation</b> ( @ByVal UMat orientation, @ByVal UMat mask, @ByVal UMat mhi, double timestamp, double duration)</td></tr>
<tr class="separator:ga2b0fa162d7e97fc6d8d5c743eb9f7e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1ff5ca68f3f39b0547c8d249b99185b"><td class="memItemLeft" align="right" valign="top">static native void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__optflow.html#gad1ff5ca68f3f39b0547c8d249b99185b">org.bytedeco.javacpp.opencv_optflow.segmentMotion</a> ( @ByVal Mat mhi, @ByVal Mat segmask, @ByRef RectVector boundingRects, double timestamp, double segThresh)</td></tr>
<tr class="memdesc:gad1ff5ca68f3f39b0547c8d249b99185b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand).  <a href="#gad1ff5ca68f3f39b0547c8d249b99185b">More...</a><br /></td></tr>
<tr class="separator:gad1ff5ca68f3f39b0547c8d249b99185b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c40ad0d4b0f8ce55f6b081001cae94"><td class="memItemLeft" align="right" valign="top"><a id="gaf6c40ad0d4b0f8ce55f6b081001cae94"></a>
static native void&#160;</td><td class="memItemRight" valign="bottom"><b>org.bytedeco.javacpp.opencv_optflow.segmentMotion</b> ( @ByVal UMat mhi, @ByVal UMat segmask, @ByRef RectVector boundingRects, double timestamp, double segThresh)</td></tr>
<tr class="separator:gaf6c40ad0d4b0f8ce55f6b081001cae94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Updates the motion history image by a moving silhouette. </p>
<p>Dense optical flow algorithms compute motion for each point: </p>
<ul>
<li>cv::optflow::calcOpticalFlowSF</li>
<li>cv::optflow::createOptFlow_DeepFlow </li>
</ul>
<p>Motion templates is alternative technique for detecting motion and computing its direction. See samples/motempl.py. </p>
<ul>
<li>cv::motempl::updateMotionHistory</li>
<li>cv::motempl::calcMotionGradient</li>
<li>cv::motempl::calcGlobalOrientation</li>
<li>cv::motempl::segmentMotion </li>
</ul>
<p>Functions reading and writing .flo files in "Middlebury" format, see: <a href="http://vision.middlebury.edu/flow/code/flow-code/README.txt">http://vision.middlebury.edu/flow/code/flow-code/README.txt</a> </p>
<ul>
<li>cv::optflow::readOpticalFlow</li>
<li>cv::optflow::writeOpticalFlow </li>
</ul>
<p>/**This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>/**</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">silhouette</td><td>Silhouette mask that has non-zero pixels where the motion occurs. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image that is updated by the function (single-channel, 32-bit floating-point). </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">duration</td><td>Maximal duration of the motion track in the same units as timestamp . </td></tr>
  </table>
  </dd>
</dl>
<p>The function updates the motion history image as follows: </p>
<p class="formulaDsp">
\[\texttt{mhi} (x,y)= \forkthree{\texttt{timestamp}}{if \(\texttt{silhouette}(x,y) \ne 0\)}{0}{if \(\texttt{silhouette}(x,y) = 0\) and \(\texttt{mhi} &lt; (\texttt{timestamp} - \texttt{duration})\)}{\texttt{mhi}(x,y)}{otherwise}\]
</p>
 <p>That is, MHI pixels where the motion occurs are set to the current timestamp , while the pixels where the motion happened last time a long time ago are cleared. </p>
<p>The function, together with calcMotionGradient and calcGlobalOrientation , implements a motion templates technique described in <b>[Davis97]</b> and <b>[Bradski00]</b> . </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae09be23e6ebae54e6dad95914a82282d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae09be23e6ebae54e6dad95914a82282d">&#9670;&nbsp;</a></span>calcGlobalOrientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native double org.bytedeco.javacpp.opencv_optflow.calcGlobalOrientation </td>
          <td>(</td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>duration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a global motion orientation in a selected region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orientation</td><td>Motion gradient orientation image calculated by the function calcMotionGradient </td></tr>
    <tr><td class="paramname">mask</td><td>Mask image. It may be a conjunction of a valid gradient mask, also calculated by calcMotionGradient , and the mask of a region whose direction needs to be calculated. </td></tr>
    <tr><td class="paramname">mhi</td><td>Motion history image calculated by updateMotionHistory . </td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp passed to updateMotionHistory . </td></tr>
    <tr><td class="paramname">duration</td><td>Maximum duration of a motion track in milliseconds, passed to updateMotionHistory </td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates an average motion direction in the selected region and returns the angle between 0 degrees and 360 degrees. The average direction is computed from the weighted orientation histogram, where a recent motion has a larger weight and the motion occurred in the past has a smaller weight, as recorded in mhi . </p>

</div>
</div>
<a id="ga1df8e7b81e72fc2df163a156ec07b5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1df8e7b81e72fc2df163a156ec07b5ed">&#9670;&nbsp;</a></span>calcMotionGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native void org.bytedeco.javacpp.opencv_optflow.calcMotionGradient </td>
          <td>(</td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>apertureSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a gradient orientation of a motion history image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history single-channel floating-point image. </td></tr>
    <tr><td class="paramname">mask</td><td>Output mask image that has the type CV_8UC1 and the same size as mhi . Its non-zero elements mark pixels where the motion gradient data is correct. </td></tr>
    <tr><td class="paramname">orientation</td><td>Output motion gradient orientation image that has the same type and the same size as mhi . Each pixel of the image is a motion orientation, from 0 to 360 degrees. </td></tr>
    <tr><td class="paramname">delta1</td><td>Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood. </td></tr>
    <tr><td class="paramname">delta2</td><td>Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. That is, the function finds the minimum ( \(m(x,y)\) ) and maximum ( \(M(x,y)\) ) mhi values over \(3 \times 3\) neighborhood of each pixel and marks the motion orientation at \((x, y)\) as valid only if <p class="formulaDsp">
\[\min ( \texttt{delta1} , \texttt{delta2} ) \le M(x,y)-m(x,y) \le \max ( \texttt{delta1} , \texttt{delta2} ).\]
</p>
 </td></tr>
    <tr><td class="paramname">apertureSize</td><td>Aperture size of the Sobel operator. </td></tr>
  </table>
  </dd>
</dl>
<p>The function calculates a gradient orientation at each pixel \((x, y)\) as: </p>
<p class="formulaDsp">
\[\texttt{orientation} (x,y)= \arctan{\frac{d\texttt{mhi}/dy}{d\texttt{mhi}/dx}}\]
</p>
 <p>In fact, fastAtan2 and phase are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the mask is filled to indicate pixels where the computed angle is valid. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>(Python) An example on how to perform a motion template technique can be found at opencv_source_code/samples/python2/motempl.py </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga76902de70b538596bed7e39b7777384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76902de70b538596bed7e39b7777384d">&#9670;&nbsp;</a></span>calcOpticalFlowSF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native void org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSF </td>
          <td>(</td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>averaging_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>postprocess_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_dist_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma_color_fix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>occ_thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upscale_averaging_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upscale_sigma_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upscale_sigma_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>speed_up_thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate an optical flow using "SimpleFlow" algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>First 8-bit 3-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>Second 8-bit 3-channel image of the same size as prev </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as prev and type CV_32FC2 </td></tr>
    <tr><td class="paramname">layers</td><td>Number of layers </td></tr>
    <tr><td class="paramname">averaging_block_size</td><td>Size of block through which we sum up when calculate cost function for pixel </td></tr>
    <tr><td class="paramname">max_flow</td><td>maximal flow that we search at each level </td></tr>
    <tr><td class="paramname">sigma_dist</td><td>vector smooth spatial sigma parameter </td></tr>
    <tr><td class="paramname">sigma_color</td><td>vector smooth color sigma parameter </td></tr>
    <tr><td class="paramname">postprocess_window</td><td>window size for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">sigma_dist_fix</td><td>spatial sigma for postprocess cross bilateralf filter </td></tr>
    <tr><td class="paramname">sigma_color_fix</td><td>color sigma for postprocess cross bilateral filter </td></tr>
    <tr><td class="paramname">occ_thr</td><td>threshold for detecting occlusions </td></tr>
    <tr><td class="paramname">upscale_averaging_radius</td><td>window size for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_dist</td><td>spatial sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">upscale_sigma_color</td><td>color sigma for bilateral upscale operation </td></tr>
    <tr><td class="paramname">speed_up_thr</td><td>threshold to detect point with irregular flow - where flow should be recalculated after upscale </td></tr>
  </table>
  </dd>
</dl>
<p>See <b>[Tao2012]</b> . And site of project - <a href="http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/">http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/</a>. </p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>An example using the simpleFlow algorithm can be found at samples/simpleflow_demo.cpp </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab202f6c782e9356cf2a96620732785a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab202f6c782e9356cf2a96620732785a9">&#9670;&nbsp;</a></span>calcOpticalFlowSparseToDense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native void org.bytedeco.javacpp.opencv_optflow.calcOpticalFlowSparseToDense </td>
          <td>(</td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>flow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>grid_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@Cast(&quot;bool&quot;) boolean&#160;</td>
          <td class="paramname"><em>use_post_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fgs_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fgs_sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast dense optical flow based on PyrLK sparse matches interpolation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>first 8-bit 3-channel or 1-channel image. </td></tr>
    <tr><td class="paramname">to</td><td>second 8-bit 3-channel or 1-channel image of the same size as from </td></tr>
    <tr><td class="paramname">flow</td><td>computed flow image that has the same size as from and CV_32FC2 type </td></tr>
    <tr><td class="paramname">grid_step</td><td>stride used in sparse match computation. Lower values usually result in higher quality but slow down the algorithm. </td></tr>
    <tr><td class="paramname">k</td><td>number of nearest-neighbor matches considered, when fitting a locally affine model. Lower values can make the algorithm noticeably faster at the cost of some quality degradation. </td></tr>
    <tr><td class="paramname">sigma</td><td>parameter defining how fast the weights decrease in the locally-weighted affine fitting. Higher values can help preserve fine details, lower values can help to get rid of the noise in the output flow. </td></tr>
    <tr><td class="paramname">use_post_proc</td><td>defines whether the ximgproc::fastGlobalSmootherFilter() is used for post-processing after interpolation </td></tr>
    <tr><td class="paramname">fgs_lambda</td><td>see the respective parameter of the ximgproc::fastGlobalSmootherFilter() </td></tr>
    <tr><td class="paramname">fgs_sigma</td><td>see the respective parameter of the ximgproc::fastGlobalSmootherFilter() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga27f2a261b7f69f4eaaf2aa2552943a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27f2a261b7f69f4eaaf2aa2552943a1a">&#9670;&nbsp;</a></span>createOptFlow_DeepFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native DenseOpticalFlow org.bytedeco.javacpp.opencv_optflow.createOptFlow_DeepFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DeepFlow optical flow algorithm implementation. </p>
<p>The class implements the DeepFlow optical flow algorithm described in <b>[Weinzaepfel2013]</b> . See also <a href="http://lear.inrialpes.fr/src/deepmatching/">http://lear.inrialpes.fr/src/deepmatching/</a> . Parameters - class fields - that may be modified after creating a class instance:</p><ul>
<li>member float alpha Smoothness assumption weight</li>
<li>member float delta Color constancy assumption weight</li>
<li>member float gamma Gradient constancy weight</li>
<li>member float sigma Gaussian smoothing parameter</li>
<li>member int minSize Minimal dimension of an image in the pyramid (next, smaller images in the pyramid are generated until one of the dimensions reaches this size)</li>
<li>member float downscaleFactor Scaling factor in the image pyramid (must be &lt; 1)</li>
<li>member int fixedPointIterations How many iterations on each level of the pyramid</li>
<li>member int sorIterations Iterations of Succesive Over-Relaxation (solver)</li>
<li>member float omega Relaxation factor in SOR </li>
</ul>

</div>
</div>
<a id="gac107283f5dba4f320df3d9894aad537b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac107283f5dba4f320df3d9894aad537b">&#9670;&nbsp;</a></span>createOptFlow_DIS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native DISOpticalFlow org.bytedeco.javacpp.opencv_optflow.createOptFlow_DIS </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>preset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an instance of DISOpticalFlow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preset</td><td>one of PRESET_ULTRAFAST, PRESET_FAST and PRESET_MEDIUM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd230cc626a64515ec35ac6c6c7fc099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd230cc626a64515ec35ac6c6c7fc099">&#9670;&nbsp;</a></span>createOptFlow_Farneback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native DenseOpticalFlow org.bytedeco.javacpp.opencv_optflow.createOptFlow_Farneback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional interface to the Farneback's algorithm - calcOpticalFlowFarneback() </p>

</div>
</div>
<a id="gace52b781a9780c4c9a20951a2bec314d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace52b781a9780c4c9a20951a2bec314d">&#9670;&nbsp;</a></span>createOptFlow_SimpleFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native DenseOpticalFlow org.bytedeco.javacpp.opencv_optflow.createOptFlow_SimpleFlow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional interface to the SimpleFlow algorithm - calcOpticalFlowSF() </p>

</div>
</div>
<a id="ga2033e98010d9ac8b150503a107601946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2033e98010d9ac8b150503a107601946">&#9670;&nbsp;</a></span>createOptFlow_SparseToDense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native DenseOpticalFlow org.bytedeco.javacpp.opencv_optflow.createOptFlow_SparseToDense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Additional interface to the SparseToDenseFlow algorithm - <a class="el" href="group__optflow.html#gab202f6c782e9356cf2a96620732785a9" title="Fast dense optical flow based on PyrLK sparse matches interpolation. ">calcOpticalFlowSparseToDense()</a> </p>

</div>
</div>
<a id="ga8adc9b054c1518ab41c20d8ada51b9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8adc9b054c1518ab41c20d8ada51b9b7">&#9670;&nbsp;</a></span>readOpticalFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native Mat org.bytedeco.javacpp.opencv_optflow.readOpticalFlow </td>
          <td>(</td>
          <td class="paramtype">@Str BytePointer&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a .flo file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to the file to be loaded </td></tr>
  </table>
  </dd>
</dl>
<p>The function readOpticalFlow loads a flow field from a file and returns it as a single matrix. Resulting Mat has a type CV_32FC2 - floating-point, 2-channel. First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). </p>

</div>
</div>
<a id="gad1ff5ca68f3f39b0547c8d249b99185b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1ff5ca68f3f39b0547c8d249b99185b">&#9670;&nbsp;</a></span>segmentMotion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native void org.bytedeco.javacpp.opencv_optflow.segmentMotion </td>
          <td>(</td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>mhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>segmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByRef RectVector&#160;</td>
          <td class="paramname"><em>boundingRects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>segThresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mhi</td><td>Motion history image. </td></tr>
    <tr><td class="paramname">segmask</td><td>Image where the found mask should be stored, single-channel, 32-bit floating-point. </td></tr>
    <tr><td class="paramname">boundingRects</td><td>Vector containing ROIs of motion connected components. </td></tr>
    <tr><td class="paramname">timestamp</td><td>Current time in milliseconds or other units. </td></tr>
    <tr><td class="paramname">segThresh</td><td>Segmentation threshold that is recommended to be equal to the interval between motion history "steps" or greater. </td></tr>
  </table>
  </dd>
</dl>
<p>The function finds all of the motion segments and marks them in segmask with individual values (1,2,...). It also computes a vector with ROIs of motion connected components. After that the motion direction for every component can be calculated with calcGlobalOrientation using the extracted mask of the particular component. </p>

</div>
</div>
<a id="ga41bea8c25211f346782adfb40129e96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41bea8c25211f346782adfb40129e96e">&#9670;&nbsp;</a></span>writeOpticalFlow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static native boolean org.bytedeco.javacpp.opencv_optflow.writeOpticalFlow </td>
          <td>(</td>
          <td class="paramtype">@Str BytePointer&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">@ByVal Mat&#160;</td>
          <td class="paramname"><em>flow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a .flo to disk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Path to the file to be written </td></tr>
    <tr><td class="paramname">flow</td><td>Flow field to be stored </td></tr>
  </table>
  </dd>
</dl>
<p>The function stores a flow field in a file, returns true on success, false otherwise. The flow field must be a 2-channel, floating-point matrix (CV_32FC2). First channel corresponds to the flow in the horizontal direction (u), second - vertical (v). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
