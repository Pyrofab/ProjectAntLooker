\hypertarget{group__video__track}{}\section{Object Tracking}
\label{group__video__track}\index{Object Tracking@{Object Tracking}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Kalman\+Filter}
\begin{DoxyCompactList}\small\item\em Kalman filter class. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Dense\+Optical\+Flow}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Sparse\+Optical\+Flow}
\begin{DoxyCompactList}\small\item\em Base interface for sparse optical flow algorithms. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Dual\+T\+V\+L1\+Optical\+Flow}
\begin{DoxyCompactList}\small\item\em \char`\"{}\+Dual T\+V L1\char`\"{} Optical Flow Algorithm. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Farneback\+Optical\+Flow}
\begin{DoxyCompactList}\small\item\em Class computing a dense optical flow using the Gunnar Farnebackâ€™s algorithm. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Sparse\+Pyr\+L\+K\+Optical\+Flow}
\begin{DoxyCompactList}\small\item\em Class used for calculating a sparse optical flow. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static native Rotated\+Rect \hyperlink{group__video__track_ga813283f225d7c4ce103da8b37981c69e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Cam\+Shift} ( @By\+Val Mat prob\+Image, @By\+Ref Rect window, @By\+Val Term\+Criteria criteria)
\begin{DoxyCompactList}\small\item\em Finds an object center, size, and orientation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_gaba49e224f6ca0cac24adb518aa3d8711}\label{group__video__track_gaba49e224f6ca0cac24adb518aa3d8711}} 
static native Rotated\+Rect {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Cam\+Shift} ( @By\+Val U\+Mat prob\+Image, @By\+Ref Rect window, @By\+Val Term\+Criteria criteria)
\item 
static native int \hyperlink{group__video__track_gad3336224aac304be4ee36ef146ec40d8}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+mean\+Shift} ( @By\+Val Mat prob\+Image, @By\+Ref Rect window, @By\+Val Term\+Criteria criteria)
\begin{DoxyCompactList}\small\item\em Finds an object on a back projection image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_ga03fda94674ccaef2a6eaf5b1744faf7d}\label{group__video__track_ga03fda94674ccaef2a6eaf5b1744faf7d}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+mean\+Shift} ( @By\+Val U\+Mat prob\+Image, @By\+Ref Rect window, @By\+Val Term\+Criteria criteria)
\item 
static native int \hyperlink{group__video__track_gafca5a72a408befa96e624e9d9704303b}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val Mat img, @By\+Val Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level, @Cast(\char`\"{}bool\char`\"{}) boolean with\+Derivatives, int pyr\+Border, int deriv\+Border, @Cast(\char`\"{}bool\char`\"{}) boolean try\+Reuse\+Input\+Image)
\begin{DoxyCompactList}\small\item\em Constructs the image pyramid which can be passed to calc\+Optical\+Flow\+Pyr\+LK. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_ga9314ba9858dbe6769c41c00d3ec0eca0}\label{group__video__track_ga9314ba9858dbe6769c41c00d3ec0eca0}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val Mat img, @By\+Val Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level)
\item 
\mbox{\Hypertarget{group__video__track_ga3ed760f32861fc26a51af5ee523a8b58}\label{group__video__track_ga3ed760f32861fc26a51af5ee523a8b58}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val Mat img, @By\+Val U\+Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level, @Cast(\char`\"{}bool\char`\"{}) boolean with\+Derivatives, int pyr\+Border, int deriv\+Border, @Cast(\char`\"{}bool\char`\"{}) boolean try\+Reuse\+Input\+Image)
\item 
\mbox{\Hypertarget{group__video__track_gace2b4fa6ce37f84ebacf9106f32cf1ff}\label{group__video__track_gace2b4fa6ce37f84ebacf9106f32cf1ff}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val Mat img, @By\+Val U\+Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level)
\item 
\mbox{\Hypertarget{group__video__track_gae92f8b92c413d1dbc8814d61a6db5c9e}\label{group__video__track_gae92f8b92c413d1dbc8814d61a6db5c9e}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val U\+Mat img, @By\+Val Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level, @Cast(\char`\"{}bool\char`\"{}) boolean with\+Derivatives, int pyr\+Border, int deriv\+Border, @Cast(\char`\"{}bool\char`\"{}) boolean try\+Reuse\+Input\+Image)
\item 
\mbox{\Hypertarget{group__video__track_ga2b1acb4e49eb8c3dc5359fec6597552b}\label{group__video__track_ga2b1acb4e49eb8c3dc5359fec6597552b}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val U\+Mat img, @By\+Val Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level)
\item 
\mbox{\Hypertarget{group__video__track_ga074f5375391e2d4c783cc1e8f9fdedf9}\label{group__video__track_ga074f5375391e2d4c783cc1e8f9fdedf9}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val U\+Mat img, @By\+Val U\+Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level, @Cast(\char`\"{}bool\char`\"{}) boolean with\+Derivatives, int pyr\+Border, int deriv\+Border, @Cast(\char`\"{}bool\char`\"{}) boolean try\+Reuse\+Input\+Image)
\item 
\mbox{\Hypertarget{group__video__track_gaf360444a172db3927b2b365318968bc7}\label{group__video__track_gaf360444a172db3927b2b365318968bc7}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid} ( @By\+Val U\+Mat img, @By\+Val U\+Mat\+Vector pyramid, @By\+Val Size win\+Size, int max\+Level)
\item 
static native void \hyperlink{group__video__track_ga5336cf64b4b2f82bf7c08551017fda66}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Pyr\+LK} ( @By\+Val Mat prev\+Img, @By\+Val Mat next\+Img, @By\+Val Mat prev\+Pts, @By\+Val Mat next\+Pts, @By\+Val Mat status, @By\+Val Mat err, @By\+Val(null\+Value=\char`\"{}cv\+::\+Size(21,21)\char`\"{}) Size win\+Size, int max\+Level, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 30, 0.\+01)\char`\"{}) Term\+Criteria criteria, int flags, double min\+Eig\+Threshold)
\begin{DoxyCompactList}\small\item\em Calculates an optical flow for a sparse feature set using the iterative Lucas-\/\+Kanade method with pyramids. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_ga70e86dff3479aed1a5dd009fcbf7c3d2}\label{group__video__track_ga70e86dff3479aed1a5dd009fcbf7c3d2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Pyr\+LK} ( @By\+Val Mat prev\+Img, @By\+Val Mat next\+Img, @By\+Val Mat prev\+Pts, @By\+Val Mat next\+Pts, @By\+Val Mat status, @By\+Val Mat err)
\item 
\mbox{\Hypertarget{group__video__track_gaca1b2a6891af84a47c0615cc72fe7978}\label{group__video__track_gaca1b2a6891af84a47c0615cc72fe7978}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Pyr\+LK} ( @By\+Val U\+Mat prev\+Img, @By\+Val U\+Mat next\+Img, @By\+Val U\+Mat prev\+Pts, @By\+Val U\+Mat next\+Pts, @By\+Val U\+Mat status, @By\+Val U\+Mat err, @By\+Val(null\+Value=\char`\"{}cv\+::\+Size(21,21)\char`\"{}) Size win\+Size, int max\+Level, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 30, 0.\+01)\char`\"{}) Term\+Criteria criteria, int flags, double min\+Eig\+Threshold)
\item 
\mbox{\Hypertarget{group__video__track_ga04584a2b791126000b147324067a66e1}\label{group__video__track_ga04584a2b791126000b147324067a66e1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Pyr\+LK} ( @By\+Val U\+Mat prev\+Img, @By\+Val U\+Mat next\+Img, @By\+Val U\+Mat prev\+Pts, @By\+Val U\+Mat next\+Pts, @By\+Val U\+Mat status, @By\+Val U\+Mat err)
\item 
static native void \hyperlink{group__video__track_ga8296f2eaf7aa279b0c54a72350493258}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Farneback} ( @By\+Val Mat prev, @By\+Val Mat next, @By\+Val Mat flow, double pyr\+\_\+scale, int levels, int winsize, int iterations, int poly\+\_\+n, double poly\+\_\+sigma, int flags)
\begin{DoxyCompactList}\small\item\em Computes a dense optical flow using the Gunnar Farneback\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_ga1e5f670704e3d8ebddef930cdeabfad9}\label{group__video__track_ga1e5f670704e3d8ebddef930cdeabfad9}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Farneback} ( @By\+Val U\+Mat prev, @By\+Val U\+Mat next, @By\+Val U\+Mat flow, double pyr\+\_\+scale, int levels, int winsize, int iterations, int poly\+\_\+n, double poly\+\_\+sigma, int flags)
\item 
static native Mat \hyperlink{group__video__track_ga2c14f71afdf82824dbdf781bbc041aa1}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+estimate\+Rigid\+Transform} ( @By\+Val Mat src, @By\+Val Mat dst, @Cast(\char`\"{}bool\char`\"{}) boolean full\+Affine)
\begin{DoxyCompactList}\small\item\em Computes an optimal affine transformation between two 2D point sets. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_gad3794cdb1f9211d985bf3d571ff4aedd}\label{group__video__track_gad3794cdb1f9211d985bf3d571ff4aedd}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+estimate\+Rigid\+Transform} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @Cast(\char`\"{}bool\char`\"{}) boolean full\+Affine)
\item 
static native double \hyperlink{group__video__track_ga2438ed3ebc7ea014e11c93797e2aae7b}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+find\+Transform\+E\+CC} ( @By\+Val Mat template\+Image, @By\+Val Mat input\+Image, @By\+Val Mat warp\+Matrix, int motion\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 50, 0.\+001)\char`\"{}) Term\+Criteria criteria, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) Mat input\+Mask)
\begin{DoxyCompactList}\small\item\em Finds the geometric transform (warp) between two images in terms of the E\+CC criterion {\bfseries [E\+P08]} . \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__video__track_gae909b79952b7cc6c3ab1d41e25818194}\label{group__video__track_gae909b79952b7cc6c3ab1d41e25818194}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+find\+Transform\+E\+CC} ( @By\+Val Mat template\+Image, @By\+Val Mat input\+Image, @By\+Val Mat warp\+Matrix)
\item 
\mbox{\Hypertarget{group__video__track_ga88ed488cd7541be16028a844f27feec0}\label{group__video__track_ga88ed488cd7541be16028a844f27feec0}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+find\+Transform\+E\+CC} ( @By\+Val U\+Mat template\+Image, @By\+Val U\+Mat input\+Image, @By\+Val U\+Mat warp\+Matrix, int motion\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 50, 0.\+001)\char`\"{}) Term\+Criteria criteria, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) U\+Mat input\+Mask)
\item 
\mbox{\Hypertarget{group__video__track_gabd03c566ba6b0cdc850ca5b9bd03a2c6}\label{group__video__track_gabd03c566ba6b0cdc850ca5b9bd03a2c6}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+find\+Transform\+E\+CC} ( @By\+Val U\+Mat template\+Image, @By\+Val U\+Mat input\+Image, @By\+Val U\+Mat warp\+Matrix)
\item 
\mbox{\Hypertarget{group__video__track_ga02df311817502c4c088084195093be2e}\label{group__video__track_ga02df311817502c4c088084195093be2e}} 
static native Dual\+T\+V\+L1\+Optical\+Flow \hyperlink{group__video__track_ga02df311817502c4c088084195093be2e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+create\+Opt\+Flow\+\_\+\+Dual\+T\+V\+L1} ()
\begin{DoxyCompactList}\small\item\em Creates instance of cv\+::\+Dense\+Optical\+Flow. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static final int \hyperlink{group__video__track_ga7544170e893b4e8835522881418d396d}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW} = 4
\item 
static final int \hyperlink{group__video__track_gaf37f7c8ec20fc62ff4ba2f00de67f1b3}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__video__track_gafca5a72a408befa96e624e9d9704303b}\label{group__video__track_gafca5a72a408befa96e624e9d9704303b}} 
\index{Object Tracking@{Object Tracking}!build\+Optical\+Flow\+Pyramid@{build\+Optical\+Flow\+Pyramid}}
\index{build\+Optical\+Flow\+Pyramid@{build\+Optical\+Flow\+Pyramid}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{build\+Optical\+Flow\+Pyramid()}{buildOpticalFlowPyramid()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+build\+Optical\+Flow\+Pyramid (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{img,  }\item[{@By\+Val Mat\+Vector}]{pyramid,  }\item[{@By\+Val Size}]{win\+Size,  }\item[{int}]{max\+Level,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{with\+Derivatives,  }\item[{int}]{pyr\+Border,  }\item[{int}]{deriv\+Border,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{try\+Reuse\+Input\+Image }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Constructs the image pyramid which can be passed to calc\+Optical\+Flow\+Pyr\+LK. 


\begin{DoxyParams}{Parameters}
{\em img} & 8-\/bit input image. \\
\hline
{\em pyramid} & output pyramid. \\
\hline
{\em win\+Size} & window size of optical flow algorithm. Must be not less than win\+Size argument of calc\+Optical\+Flow\+Pyr\+LK. It is needed to calculate required padding for pyramid levels. \\
\hline
{\em max\+Level} & 0-\/based maximal pyramid level number. \\
\hline
{\em with\+Derivatives} & set to precompute gradients for the every pyramid level. If pyramid is constructed without the gradients then calc\+Optical\+Flow\+Pyr\+LK will calculate them internally. \\
\hline
{\em pyr\+Border} & the border mode for pyramid layers. \\
\hline
{\em deriv\+Border} & the border mode for gradients. \\
\hline
{\em try\+Reuse\+Input\+Image} & put R\+OI of input image into the pyramid if possible. You can pass false to force data copying. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of levels in constructed pyramid. Can be less than max\+Level. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__video__track_ga8296f2eaf7aa279b0c54a72350493258}\label{group__video__track_ga8296f2eaf7aa279b0c54a72350493258}} 
\index{Object Tracking@{Object Tracking}!calc\+Optical\+Flow\+Farneback@{calc\+Optical\+Flow\+Farneback}}
\index{calc\+Optical\+Flow\+Farneback@{calc\+Optical\+Flow\+Farneback}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{calc\+Optical\+Flow\+Farneback()}{calcOpticalFlowFarneback()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Farneback (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{prev,  }\item[{@By\+Val Mat}]{next,  }\item[{@By\+Val Mat}]{flow,  }\item[{double}]{pyr\+\_\+scale,  }\item[{int}]{levels,  }\item[{int}]{winsize,  }\item[{int}]{iterations,  }\item[{int}]{poly\+\_\+n,  }\item[{double}]{poly\+\_\+sigma,  }\item[{int}]{flags }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Computes a dense optical flow using the Gunnar Farneback\textquotesingle{}s algorithm. 


\begin{DoxyParams}{Parameters}
{\em prev} & first 8-\/bit single-\/channel input image. \\
\hline
{\em next} & second input image of the same size and the same type as prev. \\
\hline
{\em flow} & computed flow image that has the same size as prev and type C\+V\+\_\+32\+F\+C2. \\
\hline
{\em pyr\+\_\+scale} & parameter, specifying the image scale ($<$1) to build pyramids for each image; pyr\+\_\+scale=0.\+5 means a classical pyramid, where each next layer is twice smaller than the previous one. \\
\hline
{\em levels} & number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used. \\
\hline
{\em winsize} & averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field. \\
\hline
{\em iterations} & number of iterations the algorithm does at each pyramid level. \\
\hline
{\em poly\+\_\+n} & size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field, typically poly\+\_\+n =5 or 7. \\
\hline
{\em poly\+\_\+sigma} & standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for poly\+\_\+n=5, you can set poly\+\_\+sigma=1.\+1, for poly\+\_\+n=7, a good value would be poly\+\_\+sigma=1.\+5. \\
\hline
{\em flags} & operation flags that can be a combination of the following\+:
\begin{DoxyItemize}
\item {\bfseries O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW} uses the input flow as an initial flow approximation.
\item {\bfseries O\+P\+T\+F\+L\+O\+W\+\_\+\+F\+A\+R\+N\+E\+B\+A\+C\+K\+\_\+\+G\+A\+U\+S\+S\+I\+AN} uses the Gaussian $\texttt{winsize}\times\texttt{winsize}$ filter instead of a box filter of the same size for optical flow estimation; usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; normally, winsize for a Gaussian window should be set to a larger value to achieve the same level of robustness. 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
The function finds an optical flow for each prev pixel using the {\bfseries [Farneback2003]} algorithm so that 

\[\texttt{prev} (y,x) \sim \texttt{next} ( y + \texttt{flow} (y,x)[1], x + \texttt{flow} (y,x)[0])\] 

\begin{DoxyNote}{Note}

\end{DoxyNote}

\begin{DoxyItemize}
\item An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv\+\_\+source\+\_\+code/samples/cpp/fback.\+cpp
\item (Python) An example using the optical flow algorithm described by Gunnar Farneback can be found at opencv\+\_\+source\+\_\+code/samples/python/opt\+\_\+flow.\+py 
\end{DoxyItemize}\mbox{\Hypertarget{group__video__track_ga5336cf64b4b2f82bf7c08551017fda66}\label{group__video__track_ga5336cf64b4b2f82bf7c08551017fda66}} 
\index{Object Tracking@{Object Tracking}!calc\+Optical\+Flow\+Pyr\+LK@{calc\+Optical\+Flow\+Pyr\+LK}}
\index{calc\+Optical\+Flow\+Pyr\+LK@{calc\+Optical\+Flow\+Pyr\+LK}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{calc\+Optical\+Flow\+Pyr\+L\+K()}{calcOpticalFlowPyrLK()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+calc\+Optical\+Flow\+Pyr\+LK (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{prev\+Img,  }\item[{@By\+Val Mat}]{next\+Img,  }\item[{@By\+Val Mat}]{prev\+Pts,  }\item[{@By\+Val Mat}]{next\+Pts,  }\item[{@By\+Val Mat}]{status,  }\item[{@By\+Val Mat}]{err,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Size(21,21)\char`\"{}) Size}]{win\+Size,  }\item[{int}]{max\+Level,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 30, 0.\+01)\char`\"{}) Term\+Criteria}]{criteria,  }\item[{int}]{flags,  }\item[{double}]{min\+Eig\+Threshold }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates an optical flow for a sparse feature set using the iterative Lucas-\/\+Kanade method with pyramids. 


\begin{DoxyParams}{Parameters}
{\em prev\+Img} & first 8-\/bit input image or pyramid constructed by build\+Optical\+Flow\+Pyramid. \\
\hline
{\em next\+Img} & second input image or pyramid of the same size and the same type as prev\+Img. \\
\hline
{\em prev\+Pts} & vector of 2D points for which the flow needs to be found; point coordinates must be single-\/precision floating-\/point numbers. \\
\hline
{\em next\+Pts} & output vector of 2D points (with single-\/precision floating-\/point coordinates) containing the calculated new positions of input features in the second image; when O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW flag is passed, the vector must have the same size as in the input. \\
\hline
{\em status} & output status vector (of unsigned chars); each element of the vector is set to 1 if the flow for the corresponding features has been found, otherwise, it is set to 0. \\
\hline
{\em err} & output vector of errors; each element of the vector is set to an error for the corresponding feature, type of the error measure can be set in flags parameter; if the flow wasn\textquotesingle{}t found then the error is not defined (use the status parameter to find such cases). \\
\hline
{\em win\+Size} & size of the search window at each pyramid level. \\
\hline
{\em max\+Level} & 0-\/based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than max\+Level. \\
\hline
{\em criteria} & parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.\+max\+Count or when the search window moves by less than criteria.\+epsilon. \\
\hline
{\em flags} & operation flags\+:
\begin{DoxyItemize}
\item {\bfseries O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW} uses initial estimations, stored in next\+Pts; if the flag is not set, then prev\+Pts is copied to next\+Pts and is considered the initial estimate.
\item {\bfseries O\+P\+T\+F\+L\+O\+W\+\_\+\+L\+K\+\_\+\+G\+E\+T\+\_\+\+M\+I\+N\+\_\+\+E\+I\+G\+E\+N\+V\+A\+LS} use minimum eigen values as an error measure (see min\+Eig\+Threshold description); if the flag is not set, then L1 distance between patches around the original and a moved point, divided by number of pixels in a window, is used as a error measure. 
\end{DoxyItemize}\\
\hline
{\em min\+Eig\+Threshold} & the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations (this matrix is called a spatial gradient matrix in {\bfseries [Bouguet00]}), divided by number of pixels in a window; if this value is less than min\+Eig\+Threshold, then a corresponding feature is filtered out and its flow is not processed, so it allows to remove bad points and get a performance boost. \\
\hline
\end{DoxyParams}
The function implements a sparse iterative version of the Lucas-\/\+Kanade optical flow in pyramids. See {\bfseries [Bouguet00]} . The function is parallelized with the T\+BB library. 

\begin{DoxyNote}{Note}

\end{DoxyNote}

\begin{DoxyItemize}
\item An example using the Lucas-\/\+Kanade optical flow algorithm can be found at opencv\+\_\+source\+\_\+code/samples/cpp/lkdemo.\+cpp
\item (Python) An example using the Lucas-\/\+Kanade optical flow algorithm can be found at opencv\+\_\+source\+\_\+code/samples/python/lk\+\_\+track.\+py
\item (Python) An example using the Lucas-\/\+Kanade tracker for homography matching can be found at opencv\+\_\+source\+\_\+code/samples/python/lk\+\_\+homography.\+py 
\end{DoxyItemize}\mbox{\Hypertarget{group__video__track_ga813283f225d7c4ce103da8b37981c69e}\label{group__video__track_ga813283f225d7c4ce103da8b37981c69e}} 
\index{Object Tracking@{Object Tracking}!Cam\+Shift@{Cam\+Shift}}
\index{Cam\+Shift@{Cam\+Shift}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{Cam\+Shift()}{CamShift()}}
{\footnotesize\ttfamily static native Rotated\+Rect org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+Cam\+Shift (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{prob\+Image,  }\item[{@By\+Ref Rect}]{window,  }\item[{@By\+Val Term\+Criteria}]{criteria }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds an object center, size, and orientation. 


\begin{DoxyParams}{Parameters}
{\em prob\+Image} & Back projection of the object histogram. See calc\+Back\+Project. \\
\hline
{\em window} & Initial search window. \\
\hline
{\em criteria} & Stop criteria for the underlying mean\+Shift. returns (in old interfaces) Number of iterations C\+A\+M\+S\+H\+I\+FT took to converge The function implements the C\+A\+M\+S\+H\+I\+FT object tracking algorithm {\bfseries [Bradski98]} . First, it finds an object center using mean\+Shift and then adjusts the window size and finds the optimal rotation. The function returns the rotated rectangle structure that includes the object position, size, and orientation. The next position of the search window can be obtained with Rotated\+Rect\+::bounding\+Rect() \\
\hline
\end{DoxyParams}
See the Open\+CV sample camshiftdemo.\+c that tracks colored objects. 

\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item (Python) A sample explaining the camshift tracking algorithm can be found at opencv\+\_\+source\+\_\+code/samples/python/camshift.\+py 
\end{DoxyItemize}
\end{DoxyNote}
\mbox{\Hypertarget{group__video__track_ga2c14f71afdf82824dbdf781bbc041aa1}\label{group__video__track_ga2c14f71afdf82824dbdf781bbc041aa1}} 
\index{Object Tracking@{Object Tracking}!estimate\+Rigid\+Transform@{estimate\+Rigid\+Transform}}
\index{estimate\+Rigid\+Transform@{estimate\+Rigid\+Transform}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{estimate\+Rigid\+Transform()}{estimateRigidTransform()}}
{\footnotesize\ttfamily static native Mat org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+estimate\+Rigid\+Transform (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{full\+Affine }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Computes an optimal affine transformation between two 2D point sets. 


\begin{DoxyParams}{Parameters}
{\em src} & First input 2D point set stored in std\+::vector or Mat, or an image stored in Mat. \\
\hline
{\em dst} & Second input 2D point set of the same size and the same type as A, or another image. \\
\hline
{\em full\+Affine} & If true, the function finds an optimal affine transformation with no additional restrictions (6 degrees of freedom). Otherwise, the class of transformations to choose from is limited to combinations of translation, rotation, and uniform scaling (4 degrees of freedom). \\
\hline
\end{DoxyParams}
The function finds an optimal affine transform {\itshape \mbox{[}A$\vert$b\mbox{]}} (a 2 x 3 floating-\/point matrix) that approximates best the affine transformation between\+: 

Two point sets Two raster images. In this case, the function first finds some features in the src image and finds the corresponding features in dst image. After that, the problem is reduced to the first case. In case of point sets, the problem is formulated as follows\+: you need to find a 2x2 matrix {\itshape A} and 2x1 vector {\itshape b} so that\+: 

\[[A^*|b^*] = arg \min _{[A|b]} \sum _i \| \texttt{dst}[i] - A { \texttt{src}[i]}^T - b \| ^2\] where src\mbox{[}i\mbox{]} and dst\mbox{[}i\mbox{]} are the i-\/th points in src and dst, respectively $[A|b]$ can be either arbitrary (when full\+Affine=true ) or have a form of \[\begin{bmatrix} a_{11} & a_{12} & b_1 \\ -a_{12} & a_{11} & b_2 \end{bmatrix}\] when full\+Affine=false. 

\begin{DoxySeeAlso}{See also}
estimate\+Affine2D, estimate\+Affine\+Partial2D, get\+Affine\+Transform, get\+Perspective\+Transform, find\+Homography 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__video__track_ga2438ed3ebc7ea014e11c93797e2aae7b}\label{group__video__track_ga2438ed3ebc7ea014e11c93797e2aae7b}} 
\index{Object Tracking@{Object Tracking}!find\+Transform\+E\+CC@{find\+Transform\+E\+CC}}
\index{find\+Transform\+E\+CC@{find\+Transform\+E\+CC}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{find\+Transform\+E\+C\+C()}{findTransformECC()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+find\+Transform\+E\+CC (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{template\+Image,  }\item[{@By\+Val Mat}]{input\+Image,  }\item[{@By\+Val Mat}]{warp\+Matrix,  }\item[{int}]{motion\+Type,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+C\+O\+U\+NT+cv\+::\+Term\+Criteria\+::\+E\+PS, 50, 0.\+001)\char`\"{}) Term\+Criteria}]{criteria,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) Mat}]{input\+Mask }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds the geometric transform (warp) between two images in terms of the E\+CC criterion {\bfseries [E\+P08]} . 


\begin{DoxyParams}{Parameters}
{\em template\+Image} & single-\/channel template image; C\+V\+\_\+8U or C\+V\+\_\+32F array. \\
\hline
{\em input\+Image} & single-\/channel input image which should be warped with the final warp\+Matrix in order to provide an image similar to template\+Image, same type as temlate\+Image. \\
\hline
{\em warp\+Matrix} & floating-\/point $2\times 3$ or $3\times 3$ mapping matrix (warp). \\
\hline
{\em motion\+Type} & parameter, specifying the type of motion\+:
\begin{DoxyItemize}
\item {\bfseries M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON} sets a translational motion model; warp\+Matrix is $2\times 3$ with the first $2\times 2$ part being the unity matrix and the rest two parameters being estimated.
\item {\bfseries M\+O\+T\+I\+O\+N\+\_\+\+E\+U\+C\+L\+I\+D\+E\+AN} sets a Euclidean (rigid) transformation as motion model; three parameters are estimated; warp\+Matrix is $2\times 3$.
\item {\bfseries M\+O\+T\+I\+O\+N\+\_\+\+A\+F\+F\+I\+NE} sets an affine motion model (D\+E\+F\+A\+U\+LT); six parameters are estimated; warp\+Matrix is $2\times 3$.
\item {\bfseries M\+O\+T\+I\+O\+N\+\_\+\+H\+O\+M\+O\+G\+R\+A\+P\+HY} sets a homography as a motion model; eight parameters are estimated;@code warp\+Matrix\textbackslash{}  is $3\times 3$. 
\end{DoxyItemize}\\
\hline
{\em criteria} & parameter, specifying the termination criteria of the E\+CC algorithm; criteria.\+epsilon defines the threshold of the increment in the correlation coefficient between two iterations (a negative criteria.\+epsilon makes criteria.\+maxcount the only termination criterion). Default values are shown in the declaration above. \\
\hline
{\em input\+Mask} & An optional mask to indicate valid values of input\+Image. \\
\hline
\end{DoxyParams}
The function estimates the optimum transformation (warp\+Matrix) with respect to E\+CC criterion ({\bfseries [E\+P08]}), that is 

\[\texttt{warpMatrix} = \texttt{warpMatrix} = \arg\max_{W} \texttt{ECC}(\texttt{templateImage}(x,y),\texttt{inputImage}(x',y'))\] 

where 

\[\begin{bmatrix} x' \\ y' \end{bmatrix} = W \cdot \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\] 

(the equation holds with homogeneous coordinates for homography). It returns the final enhanced correlation coefficient, that is the correlation coefficient between the template image and the final warped input image. When a $3\times 3$ matrix is given with motion\+Type =0, 1 or 2, the third row is ignored. 

Unlike find\+Homography and estimate\+Rigid\+Transform, the function find\+Transform\+E\+CC implements an area-\/based alignment that builds on intensity similarities. In essence, the function updates the initial transformation that roughly aligns the images. If this information is missing, the identity warp (unity matrix) should be given as input. Note that if images undergo strong displacements/rotations, an initial transformation that roughly aligns the images is necessary (e.\+g., a simple euclidean/similarity transform that allows for the images showing the same image content approximately). Use inverse warping in the second image to take an image close to the first one, i.\+e. use the flag W\+A\+R\+P\+\_\+\+I\+N\+V\+E\+R\+S\+E\+\_\+\+M\+AP with warp\+Affine or warp\+Perspective. See also the Open\+CV sample image\+\_\+alignment.\+cpp that demonstrates the use of the function. Note that the function throws an exception if algorithm does not converges. 

\begin{DoxySeeAlso}{See also}
estimate\+Affine2D, estimate\+Affine\+Partial2D, find\+Homography 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__video__track_gad3336224aac304be4ee36ef146ec40d8}\label{group__video__track_gad3336224aac304be4ee36ef146ec40d8}} 
\index{Object Tracking@{Object Tracking}!mean\+Shift@{mean\+Shift}}
\index{mean\+Shift@{mean\+Shift}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{mean\+Shift()}{meanShift()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+mean\+Shift (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{prob\+Image,  }\item[{@By\+Ref Rect}]{window,  }\item[{@By\+Val Term\+Criteria}]{criteria }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds an object on a back projection image. 


\begin{DoxyParams}{Parameters}
{\em prob\+Image} & Back projection of the object histogram. See calc\+Back\+Project for details. \\
\hline
{\em window} & Initial search window. \\
\hline
{\em criteria} & Stop criteria for the iterative search algorithm. returns \+: Number of iterations C\+A\+M\+S\+H\+I\+FT took to converge. The function implements the iterative object search algorithm. It takes the input back projection of an object and the initial position. The mass center in window of the back projection image is computed and the search window center shifts to the mass center. The procedure is repeated until the specified number of iterations criteria.\+max\+Count is done or until the window center shifts by less than criteria.\+epsilon. The algorithm is used inside Cam\+Shift and, unlike Cam\+Shift , the search window size or orientation do not change during the search. You can simply pass the output of calc\+Back\+Project to this function. But better results can be obtained if you pre-\/filter the back projection and remove the noise. For example, you can do this by retrieving connected components with find\+Contours , throwing away contours with small area ( contour\+Area ), and rendering the remaining contours with draw\+Contours. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item A mean-\/shift tracking sample can be found at opencv\+\_\+source\+\_\+code/samples/cpp/camshiftdemo.\+cpp 
\end{DoxyItemize}
\end{DoxyNote}


\subsection{Variable Documentation}
\mbox{\Hypertarget{group__video__track_gaf37f7c8ec20fc62ff4ba2f00de67f1b3}\label{group__video__track_gaf37f7c8ec20fc62ff4ba2f00de67f1b3}} 
\index{Object Tracking@{Object Tracking}!M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON@{M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON}}
\index{M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON@{M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON}{MOTION\_TRANSLATION}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+M\+O\+T\+I\+O\+N\+\_\+\+T\+R\+A\+N\+S\+L\+A\+T\+I\+ON = 0\hspace{0.3cm}{\ttfamily [static]}}

enum cv\+:\+: \mbox{\Hypertarget{group__video__track_ga7544170e893b4e8835522881418d396d}\label{group__video__track_ga7544170e893b4e8835522881418d396d}} 
\index{Object Tracking@{Object Tracking}!O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW@{O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW}}
\index{O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW@{O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW}!Object Tracking@{Object Tracking}}
\subsubsection{\texorpdfstring{O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW}{OPTFLOW\_USE\_INITIAL\_FLOW}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+video.\+O\+P\+T\+F\+L\+O\+W\+\_\+\+U\+S\+E\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+F\+L\+OW = 4\hspace{0.3cm}{\ttfamily [static]}}

enum cv\+:\+: 