\hypertarget{group__features2d__main}{}\section{Feature Detection and Description}
\label{group__features2d__main}\index{Feature Detection and Description@{Feature Detection and Description}}


Class implementing the B\+R\+I\+SK keypoint detector and descriptor extractor, described in {\bfseries [L\+C\+S11]} .  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+B\+R\+I\+SK}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+O\+RB}
\begin{DoxyCompactList}\small\item\em Class implementing the O\+RB ({\itshape oriented B\+R\+I\+EF}) keypoint detector and descriptor extractor. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+M\+S\+ER}
\begin{DoxyCompactList}\small\item\em Maximally stable extremal region extractor. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+Fast\+Feature\+Detector}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+Agast\+Feature\+Detector}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+G\+F\+T\+T\+Detector}
\begin{DoxyCompactList}\small\item\em Wrapping class for feature detection using the good\+Features\+To\+Track function. \+: \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+Simple\+Blob\+Detector}
\begin{DoxyCompactList}\small\item\em Class for extracting blobs from an image. \+: \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+K\+A\+ZE}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+K\+A\+ZE}
\begin{DoxyCompactList}\small\item\em Class implementing the A\+K\+A\+ZE keypoint detector and descriptor extractor, described in {\bfseries [A\+N\+B13]} . \+: \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static native void \hyperlink{group__features2d__main_gabceff7e5d16ac9f888fa12e3e8a3f39e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression)
\item 
\mbox{\Hypertarget{group__features2d__main_gaf0c4ad9499537ff96b8de123cae0fda3}\label{group__features2d__main_gaf0c4ad9499537ff96b8de123cae0fda3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold)
\item 
\mbox{\Hypertarget{group__features2d__main_ga3fc49a28e6f2b9c04a3c2ea69347d380}\label{group__features2d__main_ga3fc49a28e6f2b9c04a3c2ea69347d380}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression)
\item 
\mbox{\Hypertarget{group__features2d__main_ga9390c79e9e48ccd04748f933d7376f38}\label{group__features2d__main_ga9390c79e9e48ccd04748f933d7376f38}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold)
\item 
static native void \hyperlink{group__features2d__main_ga7b940fc6d27c261d531040a7f8dd22af}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression, int type)
\begin{DoxyCompactList}\small\item\em Detects corners using the F\+A\+ST algorithm. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__features2d__main_gaeec7bd1fd050f5aab2b5661e14277750}\label{group__features2d__main_gaeec7bd1fd050f5aab2b5661e14277750}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression, int type)
\item 
static native void \hyperlink{group__features2d__main_ga849ee8acfb310ef13c3fd8a8f25327ed}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression)
\item 
\mbox{\Hypertarget{group__features2d__main_gaf22c6f99e6b9396740f6307a096af588}\label{group__features2d__main_gaf22c6f99e6b9396740f6307a096af588}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold)
\item 
\mbox{\Hypertarget{group__features2d__main_ga8117d36086a8026863c3a8efa69889f2}\label{group__features2d__main_ga8117d36086a8026863c3a8efa69889f2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression)
\item 
\mbox{\Hypertarget{group__features2d__main_ga7754d5ff319320963db994f854dd8184}\label{group__features2d__main_ga7754d5ff319320963db994f854dd8184}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold)
\item 
static native void \hyperlink{group__features2d__main_ga2126ee1b1b70316ae0fd6ffb3d2d51bc}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression, int type)
\begin{DoxyCompactList}\small\item\em Detects corners using the A\+G\+A\+ST algorithm. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__features2d__main_gad2865f6a56af34b53c7e3ebb3abd2b6c}\label{group__features2d__main_gad2865f6a56af34b53c7e3ebb3abd2b6c}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST} ( @By\+Val U\+Mat image, @By\+Ref Key\+Point\+Vector keypoints, int threshold, @Cast(\char`\"{}bool\char`\"{}) boolean nonmax\+Suppression, int type)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class implementing the B\+R\+I\+SK keypoint detector and descriptor extractor, described in {\bfseries [L\+C\+S11]} . 

Class implementing the K\+A\+ZE keypoint detector and descriptor extractor, described in {\bfseries [A\+B\+D12]} .

Wrapping class for feature detection using the A\+G\+A\+ST method. \+:

Wrapping class for feature detection using the F\+A\+ST method. \+:

Feature detectors in Open\+CV have wrappers with a common interface that enables you to easily switch between different algorithms solving the same problem. All objects that implement keypoint detectors inherit the Feature\+Detector interface. Extractors of keypoint descriptors in Open\+CV have wrappers with a common interface that enables you to easily switch between different algorithms solving the same problem. This section is devoted to computing descriptors represented as vectors in a multidimensional space. All objects that implement the vector descriptor extractors inherit the Descriptor\+Extractor interface.

/$\ast$$\ast$

features2d\+\_\+main 

/$\ast$$\ast$

features2d\+\_\+main 

/$\ast$$\ast$

\begin{DoxyNote}{Note}
A\+K\+A\+ZE descriptor can only be used with K\+A\+ZE or A\+K\+A\+ZE keypoints .. \mbox{[}A\+B\+D12\mbox{]} K\+A\+ZE Features. Pablo F. Alcantarilla, Adrien Bartoli and Andrew J. Davison. In European Conference on Computer Vision (E\+C\+CV), Fiorenze, Italy, October 2012. 
\end{DoxyNote}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__features2d__main_ga849ee8acfb310ef13c3fd8a8f25327ed}\label{group__features2d__main_ga849ee8acfb310ef13c3fd8a8f25327ed}} 
\index{Feature Detection and Description@{Feature Detection and Description}!A\+G\+A\+ST@{A\+G\+A\+ST}}
\index{A\+G\+A\+ST@{A\+G\+A\+ST}!Feature Detection and Description@{Feature Detection and Description}}
\subsubsection{\texorpdfstring{A\+G\+A\+S\+T()}{AGAST()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Ref Key\+Point\+Vector}]{keypoints,  }\item[{int}]{threshold,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{nonmax\+Suppression }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__features2d__main_ga2126ee1b1b70316ae0fd6ffb3d2d51bc}\label{group__features2d__main_ga2126ee1b1b70316ae0fd6ffb3d2d51bc}} 
\index{Feature Detection and Description@{Feature Detection and Description}!A\+G\+A\+ST@{A\+G\+A\+ST}}
\index{A\+G\+A\+ST@{A\+G\+A\+ST}!Feature Detection and Description@{Feature Detection and Description}}
\subsubsection{\texorpdfstring{A\+G\+A\+S\+T()}{AGAST()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+A\+G\+A\+ST (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Ref Key\+Point\+Vector}]{keypoints,  }\item[{int}]{threshold,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{nonmax\+Suppression,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Detects corners using the A\+G\+A\+ST algorithm. 


\begin{DoxyParams}{Parameters}
{\em image} & grayscale image where keypoints (corners) are detected. \\
\hline
{\em keypoints} & keypoints detected on the image. \\
\hline
{\em threshold} & threshold on difference between intensity of the central pixel and pixels of a circle around this pixel. \\
\hline
{\em nonmax\+Suppression} & if true, non-\/maximum suppression is applied to detected corners (keypoints). \\
\hline
{\em type} & one of the four neighborhoods as defined in the paper\+: Agast\+Feature\+Detector\+::\+A\+G\+A\+S\+T\+\_\+5\+\_\+8, Agast\+Feature\+Detector\+::\+A\+G\+A\+S\+T\+\_\+7\+\_\+12d, Agast\+Feature\+Detector\+::\+A\+G\+A\+S\+T\+\_\+7\+\_\+12s, Agast\+Feature\+Detector\+::\+O\+A\+S\+T\+\_\+9\+\_\+16 \\
\hline
\end{DoxyParams}
For non-\/\+Intel platforms, there is a tree optimised variant of A\+G\+A\+ST with same numerical results. The 32-\/bit binary tree tables were generated automatically from original code using perl script. The perl script and examples of tree generation are placed in features2d/doc folder. Detects corners using the A\+G\+A\+ST algorithm by {\bfseries [mair2010\+\_\+agast]} . \mbox{\Hypertarget{group__features2d__main_gabceff7e5d16ac9f888fa12e3e8a3f39e}\label{group__features2d__main_gabceff7e5d16ac9f888fa12e3e8a3f39e}} 
\index{Feature Detection and Description@{Feature Detection and Description}!F\+A\+ST@{F\+A\+ST}}
\index{F\+A\+ST@{F\+A\+ST}!Feature Detection and Description@{Feature Detection and Description}}
\subsubsection{\texorpdfstring{F\+A\+S\+T()}{FAST()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Ref Key\+Point\+Vector}]{keypoints,  }\item[{int}]{threshold,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{nonmax\+Suppression }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__features2d__main_ga7b940fc6d27c261d531040a7f8dd22af}\label{group__features2d__main_ga7b940fc6d27c261d531040a7f8dd22af}} 
\index{Feature Detection and Description@{Feature Detection and Description}!F\+A\+ST@{F\+A\+ST}}
\index{F\+A\+ST@{F\+A\+ST}!Feature Detection and Description@{Feature Detection and Description}}
\subsubsection{\texorpdfstring{F\+A\+S\+T()}{FAST()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+features2d.\+F\+A\+ST (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Ref Key\+Point\+Vector}]{keypoints,  }\item[{int}]{threshold,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{nonmax\+Suppression,  }\item[{int}]{type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Detects corners using the F\+A\+ST algorithm. 


\begin{DoxyParams}{Parameters}
{\em image} & grayscale image where keypoints (corners) are detected. \\
\hline
{\em keypoints} & keypoints detected on the image. \\
\hline
{\em threshold} & threshold on difference between intensity of the central pixel and pixels of a circle around this pixel. \\
\hline
{\em nonmax\+Suppression} & if true, non-\/maximum suppression is applied to detected corners (keypoints). \\
\hline
{\em type} & one of the three neighborhoods as defined in the paper\+: Fast\+Feature\+Detector\+::\+T\+Y\+P\+E\+\_\+9\+\_\+16, Fast\+Feature\+Detector\+::\+T\+Y\+P\+E\+\_\+7\+\_\+12, Fast\+Feature\+Detector\+::\+T\+Y\+P\+E\+\_\+5\+\_\+8 \\
\hline
\end{DoxyParams}
Detects corners using the F\+A\+ST algorithm by {\bfseries [Rosten06]} . 

\begin{DoxyNote}{Note}
In Python A\+PI, types are given as cv2.\+F\+A\+S\+T\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+D\+E\+T\+E\+C\+T\+O\+R\+\_\+\+T\+Y\+P\+E\+\_\+5\+\_\+8, cv2.\+F\+A\+S\+T\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+D\+E\+T\+E\+C\+T\+O\+R\+\_\+\+T\+Y\+P\+E\+\_\+7\+\_\+12 and cv2.\+F\+A\+S\+T\+\_\+\+F\+E\+A\+T\+U\+R\+E\+\_\+\+D\+E\+T\+E\+C\+T\+O\+R\+\_\+\+T\+Y\+P\+E\+\_\+9\+\_\+16. For corner detection, use cv2.\+F\+A\+S\+T.\+detect() method. 
\end{DoxyNote}
