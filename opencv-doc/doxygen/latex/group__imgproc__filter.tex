\hypertarget{group__imgproc__filter}{}\section{Image Filtering}
\label{group__imgproc__filter}\index{Image Filtering@{Image Filtering}}


Returns Gaussian filter coefficients.  


\subsection*{Modules}
\begin{DoxyCompactItemize}
\item 
\hyperlink{group__imgproc__transform}{Geometric Image Transformations}
\begin{DoxyCompactList}\small\item\em Dilates an image by using a specific structuring element. \end{DoxyCompactList}\item 
\hyperlink{group__imgproc__misc}{Miscellaneous Image Transformations}
\begin{DoxyCompactList}\small\item\em Applies a fixed-\/level threshold to each array element. \end{DoxyCompactList}\item 
\hyperlink{group__imgproc__motion}{Motion Analysis and Object Tracking}
\begin{DoxyCompactList}\small\item\em Adds an image to the accumulator. \end{DoxyCompactList}\item 
\hyperlink{group__imgproc__hist}{Histograms}
\item 
\hyperlink{group__imgproc__shape}{Structural Analysis and Shape Descriptors}
\begin{DoxyCompactList}\small\item\em Calculates all of the moments up to the third order of a polygon or rasterized shape. \end{DoxyCompactList}\item 
\hyperlink{group__imgproc__object}{Object Detection}
\item 
\hyperlink{group__imgproc__colormap}{Color\+Maps in Open\+CV}
\item 
\hyperlink{group__imgproc__draw}{Drawing Functions}
\begin{DoxyCompactList}\small\item\em Draws a line segment connecting two points. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga78d72770238ad9e6346f095e2dd4129a}\label{group__imgproc__filter_ga78d72770238ad9e6346f095e2dd4129a}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Gaussian\+Kernel} (int ksize, double sigma, int ktype)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gab8bfd31a460b6bdd01e2c5223aff10cf}\label{group__imgproc__filter_gab8bfd31a460b6bdd01e2c5223aff10cf}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Gaussian\+Kernel} (int ksize, double sigma)
\item 
static native void \hyperlink{group__imgproc__filter_ga6e163a3c7af7f53953629e3bc1a4d5ea}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Deriv\+Kernels} ( @By\+Val Mat kx, @By\+Val Mat ky, int dx, int dy, int ksize, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int ktype)
\begin{DoxyCompactList}\small\item\em Returns filter coefficients for computing spatial image derivatives. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gad0867cdcbc4f3b2dfddbebe3d3088abf}\label{group__imgproc__filter_gad0867cdcbc4f3b2dfddbebe3d3088abf}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Deriv\+Kernels} ( @By\+Val Mat kx, @By\+Val Mat ky, int dx, int dy, int ksize)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga22960dc8afd97615eef765be7214efbe}\label{group__imgproc__filter_ga22960dc8afd97615eef765be7214efbe}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Deriv\+Kernels} ( @By\+Val U\+Mat kx, @By\+Val U\+Mat ky, int dx, int dy, int ksize, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int ktype)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaf4de92968523f2b4b8f47a500b445766}\label{group__imgproc__filter_gaf4de92968523f2b4b8f47a500b445766}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Deriv\+Kernels} ( @By\+Val U\+Mat kx, @By\+Val U\+Mat ky, int dx, int dy, int ksize)
\item 
static native Mat \hyperlink{group__imgproc__filter_ga8c30992daccc2467cea3d7d2f016a9ab}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Gabor\+Kernel} ( @By\+Val Size ksize, double sigma, double theta, double lambd, double gamma, double psi, int ktype)
\begin{DoxyCompactList}\small\item\em Returns Gabor filter coefficients. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gae7ca988b2551ca6bc75e4ec85bb116fe}\label{group__imgproc__filter_gae7ca988b2551ca6bc75e4ec85bb116fe}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Gabor\+Kernel} ( @By\+Val Size ksize, double sigma, double theta, double lambd, double gamma)
\item 
static native Scalar \hyperlink{group__imgproc__filter_gaa77a7ec53d115ff76de4c8797d6d83f7}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+morphology\+Default\+Border\+Value} ()
\item 
static native Mat \hyperlink{group__imgproc__filter_ga18af407581ba537b9095d14090cce31a}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Structuring\+Element} (int shape, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor)
\begin{DoxyCompactList}\small\item\em Returns a structuring element of the specified size and shape for morphological operations. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga0840116f63e9ca427336aed0a2d8ca55}\label{group__imgproc__filter_ga0840116f63e9ca427336aed0a2d8ca55}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Structuring\+Element} (int shape, @By\+Val Size ksize)
\item 
static native void \hyperlink{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+median\+Blur} ( @By\+Val Mat src, @By\+Val Mat dst, int ksize)
\begin{DoxyCompactList}\small\item\em Blurs an image using the median filter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gaadee3f7173f2333706cd6c0386947dfe}\label{group__imgproc__filter_gaadee3f7173f2333706cd6c0386947dfe}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+median\+Blur} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ksize)
\item 
static native void \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Gaussian\+Blur} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Size ksize, double sigmaX, double sigmaY, int border\+Type)
\begin{DoxyCompactList}\small\item\em Blurs an image using a Gaussian filter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga5436223800bf00e56241c7b4f4cceb82}\label{group__imgproc__filter_ga5436223800bf00e56241c7b4f4cceb82}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Gaussian\+Blur} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Size ksize, double sigmaX)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gadbb35488e6d6fa62f650cc63f07f61ef}\label{group__imgproc__filter_gadbb35488e6d6fa62f650cc63f07f61ef}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Gaussian\+Blur} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val Size ksize, double sigmaX, double sigmaY, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga115a0ed9b751bdcf6c95cee0437eb35d}\label{group__imgproc__filter_ga115a0ed9b751bdcf6c95cee0437eb35d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Gaussian\+Blur} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val Size ksize, double sigmaX)
\item 
static native void \hyperlink{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bilateral\+Filter} ( @By\+Val Mat src, @By\+Val Mat dst, int d, double sigma\+Color, double sigma\+Space, int border\+Type)
\begin{DoxyCompactList}\small\item\em Applies the bilateral filter to an image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga100abc7b6604cc022372a61f7c7f85ea}\label{group__imgproc__filter_ga100abc7b6604cc022372a61f7c7f85ea}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bilateral\+Filter} ( @By\+Val Mat src, @By\+Val Mat dst, int d, double sigma\+Color, double sigma\+Space)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gab8e7ddbf6f483c6b5510fcc2a1d9dccc}\label{group__imgproc__filter_gab8e7ddbf6f483c6b5510fcc2a1d9dccc}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bilateral\+Filter} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int d, double sigma\+Color, double sigma\+Space, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga4365573ba2b1f21196b689634f7bcfea}\label{group__imgproc__filter_ga4365573ba2b1f21196b689634f7bcfea}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bilateral\+Filter} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int d, double sigma\+Color, double sigma\+Space)
\item 
static native void \hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Filter} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int border\+Type)
\begin{DoxyCompactList}\small\item\em Blurs an image using the box filter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gabd35586e95d9c496428ff5883fb88c1a}\label{group__imgproc__filter_gabd35586e95d9c496428ff5883fb88c1a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Filter} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Size ksize)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga9a5b129f9524b7ce80d094e58a5977a6}\label{group__imgproc__filter_ga9a5b129f9524b7ce80d094e58a5977a6}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Filter} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga9130f8858ef9c58528215e2b91a7b1fe}\label{group__imgproc__filter_ga9130f8858ef9c58528215e2b91a7b1fe}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Filter} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val Size ksize)
\item 
static native void \hyperlink{group__imgproc__filter_gac3bb5f90c81da13be223978755c103e2}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sqr\+Box\+Filter} ( @By\+Val Mat \+\_\+src, @By\+Val Mat \+\_\+dst, int ddepth, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1, -\/1)\char`\"{}) Point anchor, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int border\+Type)
\begin{DoxyCompactList}\small\item\em Calculates the normalized sum of squares of the pixel values overlapping the filter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gac69e2c5aa5aa8e1b1bf2ded1097813f1}\label{group__imgproc__filter_gac69e2c5aa5aa8e1b1bf2ded1097813f1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sqr\+Box\+Filter} ( @By\+Val Mat \+\_\+src, @By\+Val Mat \+\_\+dst, int ddepth, @By\+Val Size ksize)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gae438b3dd3418a0a16ebe6ccab65f8260}\label{group__imgproc__filter_gae438b3dd3418a0a16ebe6ccab65f8260}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sqr\+Box\+Filter} ( @By\+Val U\+Mat \+\_\+src, @By\+Val U\+Mat \+\_\+dst, int ddepth, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1, -\/1)\char`\"{}) Point anchor, @Cast(\char`\"{}bool\char`\"{}) boolean normalize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gae60998a04ea1d80b4998496348eb7dda}\label{group__imgproc__filter_gae60998a04ea1d80b4998496348eb7dda}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sqr\+Box\+Filter} ( @By\+Val U\+Mat \+\_\+src, @By\+Val U\+Mat \+\_\+dst, int ddepth, @By\+Val Size ksize)
\item 
static native void \hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blur} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, int border\+Type)
\begin{DoxyCompactList}\small\item\em Blurs an image using the normalized box filter. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga4830c7c2c9e1f24506bac7bf41da80f0}\label{group__imgproc__filter_ga4830c7c2c9e1f24506bac7bf41da80f0}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blur} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Size ksize)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaf8d9d0c058877480d92f97c45f328347}\label{group__imgproc__filter_gaf8d9d0c058877480d92f97c45f328347}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blur} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val Size ksize, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga8c4367bdc80978100e7b53b8db658752}\label{group__imgproc__filter_ga8c4367bdc80978100e7b53b8db658752}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blur} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val Size ksize)
\item 
static native void \hyperlink{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+filter2D} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Mat kernel, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, double delta, int border\+Type)
\begin{DoxyCompactList}\small\item\em Convolves an image with the kernel. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga32707e41b29e2f45a57863769aed9dda}\label{group__imgproc__filter_ga32707e41b29e2f45a57863769aed9dda}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+filter2D} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Mat kernel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaae4b6c9ace5e9419ee9a3f1f883bda50}\label{group__imgproc__filter_gaae4b6c9ace5e9419ee9a3f1f883bda50}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+filter2D} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val U\+Mat kernel, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, double delta, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gab00b34dd987b71bf76d7106f14642f4e}\label{group__imgproc__filter_gab00b34dd987b71bf76d7106f14642f4e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+filter2D} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val U\+Mat kernel)
\item 
static native void \hyperlink{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sep\+Filter2D} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Mat kernelX, @By\+Val Mat kernelY, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, double delta, int border\+Type)
\begin{DoxyCompactList}\small\item\em Applies a separable linear filter to an image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gaf2d8d962ce153aab98ee6c5d0637c731}\label{group__imgproc__filter_gaf2d8d962ce153aab98ee6c5d0637c731}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sep\+Filter2D} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, @By\+Val Mat kernelX, @By\+Val Mat kernelY)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga2035b246fa133c96e4469b8566b7674b}\label{group__imgproc__filter_ga2035b246fa133c96e4469b8566b7674b}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sep\+Filter2D} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val U\+Mat kernelX, @By\+Val U\+Mat kernelY, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, double delta, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga0581b57344a84bf92ed8304a31c0d5ae}\label{group__imgproc__filter_ga0581b57344a84bf92ed8304a31c0d5ae}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sep\+Filter2D} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, @By\+Val U\+Mat kernelX, @By\+Val U\+Mat kernelY)
\item 
static native void \hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Sobel} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int border\+Type)
\begin{DoxyCompactList}\small\item\em Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gabccce6b56a1dddcbe6e5477e72bfdace}\label{group__imgproc__filter_gabccce6b56a1dddcbe6e5477e72bfdace}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Sobel} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, int dx, int dy)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gab3caf932611ece89e8bed4dcdf598fd4}\label{group__imgproc__filter_gab3caf932611ece89e8bed4dcdf598fd4}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Sobel} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, int dx, int dy, int ksize, double scale, double delta, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gafa284cff1dffaff09659785f42a8a389}\label{group__imgproc__filter_gafa284cff1dffaff09659785f42a8a389}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Sobel} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, int dx, int dy)
\item 
static native void \hyperlink{group__imgproc__filter_ga9263e9262b1d9a29e4dc3180d4ee2683}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+spatial\+Gradient} ( @By\+Val Mat src, @By\+Val Mat dx, @By\+Val Mat dy, int ksize, int border\+Type)
\begin{DoxyCompactList}\small\item\em Calculates the first order image derivative in both x and y using a Sobel operator. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gaf7fe45c6c7a7b791fe6683227e80f220}\label{group__imgproc__filter_gaf7fe45c6c7a7b791fe6683227e80f220}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+spatial\+Gradient} ( @By\+Val Mat src, @By\+Val Mat dx, @By\+Val Mat dy)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gae2ccdf9f61018c4bf9c3dbf48f603257}\label{group__imgproc__filter_gae2ccdf9f61018c4bf9c3dbf48f603257}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+spatial\+Gradient} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dx, @By\+Val U\+Mat dy, int ksize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga87516c2f840e0444c4284be8c686971d}\label{group__imgproc__filter_ga87516c2f840e0444c4284be8c686971d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+spatial\+Gradient} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dx, @By\+Val U\+Mat dy)
\item 
static native void \hyperlink{group__imgproc__filter_gabd4c276a8055604be5e13e061eee74a1}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Scharr} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, int dx, int dy, double scale, double delta, int border\+Type)
\begin{DoxyCompactList}\small\item\em Calculates the first x-\/ or y-\/ image derivative using Scharr operator. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gaf8b36fd326b781bdfbe1b71222cddc76}\label{group__imgproc__filter_gaf8b36fd326b781bdfbe1b71222cddc76}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Scharr} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, int dx, int dy)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gae9f59b1abc18c3bce3619ff427aa27fd}\label{group__imgproc__filter_gae9f59b1abc18c3bce3619ff427aa27fd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Scharr} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, int dx, int dy, double scale, double delta, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga8aa42854b5ace626e6e40c3d80921e27}\label{group__imgproc__filter_ga8aa42854b5ace626e6e40c3d80921e27}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Scharr} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, int dx, int dy)
\item 
static native void \hyperlink{group__imgproc__filter_ga223106fa434e6e5dee1974eab81bbf26}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Laplacian} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth, int ksize, double scale, double delta, int border\+Type)
\begin{DoxyCompactList}\small\item\em Calculates the Laplacian of an image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_gabbed757ee3966f8466a886e2eab4abbb}\label{group__imgproc__filter_gabbed757ee3966f8466a886e2eab4abbb}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Laplacian} ( @By\+Val Mat src, @By\+Val Mat dst, int ddepth)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga53a73c7ebe19e765d5a5c3ddd0021e93}\label{group__imgproc__filter_ga53a73c7ebe19e765d5a5c3ddd0021e93}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Laplacian} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth, int ksize, double scale, double delta, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaef7e4f2a12bc667667e94f5706fc7576}\label{group__imgproc__filter_gaef7e4f2a12bc667667e94f5706fc7576}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Laplacian} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, int ddepth)
\item 
static native void \hyperlink{group__imgproc__filter_ga8c0cbcc8dd271aada560698924d19cb2}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+erode} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Mat kernel, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, int iterations, int border\+Type, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Scalar(cv\+::morphology\+Default\+Border\+Value())\char`\"{}) Scalar border\+Value)
\begin{DoxyCompactList}\small\item\em Erodes an image by using a specific structuring element. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga650836745d55fe30014d0893f9bc7571}\label{group__imgproc__filter_ga650836745d55fe30014d0893f9bc7571}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+erode} ( @By\+Val Mat src, @By\+Val Mat dst, @By\+Val Mat kernel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga49298d4b54f3535b97b7b03ed29c978a}\label{group__imgproc__filter_ga49298d4b54f3535b97b7b03ed29c978a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+erode} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val U\+Mat kernel, @By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point anchor, int iterations, int border\+Type, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Scalar(cv\+::morphology\+Default\+Border\+Value())\char`\"{}) Scalar border\+Value)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaa69046fef163679ef621d83d2b3d3862}\label{group__imgproc__filter_gaa69046fef163679ef621d83d2b3d3862}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+erode} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @By\+Val U\+Mat kernel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaa693157393014e3fb1c9a3b4f69e34b2}\label{group__imgproc__filter_gaa693157393014e3fb1c9a3b4f69e34b2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Down} ( @By\+Val Mat src, @By\+Val Mat dst, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Size()\char`\"{}) Size dstsize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga6167f0b3199c77f153568fef1ec87d40}\label{group__imgproc__filter_ga6167f0b3199c77f153568fef1ec87d40}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Down} ( @By\+Val Mat src, @By\+Val Mat dst)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga12e2b2a852d66ee84fc6f8f12bd1595d}\label{group__imgproc__filter_ga12e2b2a852d66ee84fc6f8f12bd1595d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Down} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Size()\char`\"{}) Size dstsize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga009cea20a2927a644c664d67064ce059}\label{group__imgproc__filter_ga009cea20a2927a644c664d67064ce059}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Down} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst)
\item 
static native void \hyperlink{group__imgproc__filter_ga3fc37612b218d8cee2f4b099a8d0a2aa}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Up} ( @By\+Val Mat src, @By\+Val Mat dst, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Size()\char`\"{}) Size dstsize, int border\+Type)
\begin{DoxyCompactList}\small\item\em Upsamples an image and then blurs it. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga55da6cb1d91eb7a7504e550a0ac6e3d3}\label{group__imgproc__filter_ga55da6cb1d91eb7a7504e550a0ac6e3d3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Up} ( @By\+Val Mat src, @By\+Val Mat dst)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga03cf4a3c424de015336497afb357f094}\label{group__imgproc__filter_ga03cf4a3c424de015336497afb357f094}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Up} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, @Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Size()\char`\"{}) Size dstsize, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga2ef5bddb838547a49fedab3518de3da3}\label{group__imgproc__filter_ga2ef5bddb838547a49fedab3518de3da3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Up} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst)
\item 
static native void \hyperlink{group__imgproc__filter_ga418b215211fecb0c256c9db02d80dd0e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val Mat src, @By\+Val Mat\+Vector dst, int maxlevel, int border\+Type)
\begin{DoxyCompactList}\small\item\em Constructs the Gaussian pyramid for an image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__filter_ga17e294004abf5bf35e6ba1e8932d4068}\label{group__imgproc__filter_ga17e294004abf5bf35e6ba1e8932d4068}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val Mat src, @By\+Val Mat\+Vector dst, int maxlevel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga06bef881b57f22d92ba76260f6726637}\label{group__imgproc__filter_ga06bef881b57f22d92ba76260f6726637}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val Mat src, @By\+Val U\+Mat\+Vector dst, int maxlevel, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga5bcefcff889f50651f9009cc9c277fea}\label{group__imgproc__filter_ga5bcefcff889f50651f9009cc9c277fea}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val Mat src, @By\+Val U\+Mat\+Vector dst, int maxlevel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga23df81c790fcf208aaf8100c12e982e4}\label{group__imgproc__filter_ga23df81c790fcf208aaf8100c12e982e4}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val U\+Mat src, @By\+Val Mat\+Vector dst, int maxlevel, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga0d03e58e45765e1a2c32da446782d85f}\label{group__imgproc__filter_ga0d03e58e45765e1a2c32da446782d85f}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val U\+Mat src, @By\+Val Mat\+Vector dst, int maxlevel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaec3a86fcf530d0110b9dcde9e37c73e3}\label{group__imgproc__filter_gaec3a86fcf530d0110b9dcde9e37c73e3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val U\+Mat src, @By\+Val U\+Mat\+Vector dst, int maxlevel, int border\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gaa018e0328589d5ad75d8cd2cd1a85e8d}\label{group__imgproc__filter_gaa018e0328589d5ad75d8cd2cd1a85e8d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid} ( @By\+Val U\+Mat src, @By\+Val U\+Mat\+Vector dst, int maxlevel)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga74042529e3a3ecd92e161e5b62548ed5}\label{group__imgproc__filter_ga74042529e3a3ecd92e161e5b62548ed5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+watershed} ( @By\+Val U\+Mat image, @By\+Val U\+Mat markers)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gac432ef4564feb8b2e1a2deac4db12913}\label{group__imgproc__filter_gac432ef4564feb8b2e1a2deac4db12913}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Mean\+Shift\+Filtering} ( @By\+Val Mat src, @By\+Val Mat dst, double sp, double sr, int max\+Level, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+M\+A\+X\+\_\+\+I\+T\+ER+cv\+::\+Term\+Criteria\+::\+E\+PS,5,1)\char`\"{}) Term\+Criteria termcrit)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gade4d4ba80ee1a0a3ac366425edf6b911}\label{group__imgproc__filter_gade4d4ba80ee1a0a3ac366425edf6b911}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Mean\+Shift\+Filtering} ( @By\+Val Mat src, @By\+Val Mat dst, double sp, double sr)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga154238333e747daf891663cdb33d1a33}\label{group__imgproc__filter_ga154238333e747daf891663cdb33d1a33}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Mean\+Shift\+Filtering} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, double sp, double sr, int max\+Level, @By\+Val(null\+Value=\char`\"{}cv\+::\+Term\+Criteria(cv\+::\+Term\+Criteria\+::\+M\+A\+X\+\_\+\+I\+T\+ER+cv\+::\+Term\+Criteria\+::\+E\+PS,5,1)\char`\"{}) Term\+Criteria termcrit)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga8e24348e55b95d864865d7c1903e7555}\label{group__imgproc__filter_ga8e24348e55b95d864865d7c1903e7555}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Mean\+Shift\+Filtering} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst, double sp, double sr)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga43b092e00aaf90fda456fb6613004018}\label{group__imgproc__filter_ga43b092e00aaf90fda456fb6613004018}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+demosaicing} (@By\+Val Mat \+\_\+src, @By\+Val Mat \+\_\+dst, int code, int dcn)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga50b3861706458e84ba09dc916db23498}\label{group__imgproc__filter_ga50b3861706458e84ba09dc916db23498}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+demosaicing} (@By\+Val Mat \+\_\+src, @By\+Val Mat \+\_\+dst, int code)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gac1393006c09ce6896767536b0c184d21}\label{group__imgproc__filter_gac1393006c09ce6896767536b0c184d21}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+demosaicing} (@By\+Val U\+Mat \+\_\+src, @By\+Val U\+Mat \+\_\+dst, int code, int dcn)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga79a9d147081b0e7d93445844fadb8f7f}\label{group__imgproc__filter_ga79a9d147081b0e7d93445844fadb8f7f}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+demosaicing} (@By\+Val U\+Mat \+\_\+src, @By\+Val U\+Mat \+\_\+dst, int code)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga27340c3d82734719ed4587b492128ce0}\label{group__imgproc__filter_ga27340c3d82734719ed4587b492128ce0}} 
static native C\+L\+A\+HE {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+C\+L\+A\+HE} (double clip\+Limit, @By\+Val(null\+Value=\char`\"{}cv\+::\+Size(8, 8)\char`\"{}) Size tile\+Grid\+Size)
\item 
\mbox{\Hypertarget{group__imgproc__filter_ga4c917bd1387042f801f75e5ebec325be}\label{group__imgproc__filter_ga4c917bd1387042f801f75e5ebec325be}} 
static native C\+L\+A\+HE {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+C\+L\+A\+HE} ()
\item 
static native Generalized\+Hough\+Ballard \hyperlink{group__imgproc__filter_ga9184647c04f254c7cfa32edf2cb43bec}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+Generalized\+Hough\+Ballard} ()
\item 
static native Generalized\+Hough\+Guil \hyperlink{group__imgproc__filter_ga5b2d07c2bc26dfd8aa2daeae1b3adfac}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+Generalized\+Hough\+Guil} ()
\item 
static native void \hyperlink{group__imgproc__filter_gadbbb8985760a3feef02011466803a5a2}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blend\+Linear} (@By\+Val Mat src1, @By\+Val Mat src2, @By\+Val Mat weights1, @By\+Val Mat weights2, @By\+Val Mat dst)
\item 
\mbox{\Hypertarget{group__imgproc__filter_gacecd2a8eb530d74bf8a70ac2497c5945}\label{group__imgproc__filter_gacecd2a8eb530d74bf8a70ac2497c5945}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blend\+Linear} (@By\+Val U\+Mat src1, @By\+Val U\+Mat src2, @By\+Val U\+Mat weights1, @By\+Val U\+Mat weights2, @By\+Val U\+Mat dst)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static final int \hyperlink{group__imgproc__filter_ga0f22b83b4ad2465132087b8d059a2101}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE} = 0
\item 
static final int \hyperlink{group__imgproc__filter_ga8380bc8d565b30f65b81f16987e9edeb}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+M\+O\+R\+P\+H\+\_\+\+R\+E\+CT} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Returns Gaussian filter coefficients. 

Performs initial step of meanshift segmentation of an image.

Blurs an image and downsamples it.

Functions and classes described in this section are used to perform various linear or non-\/linear filtering operations on 2D images (represented as Mat\textquotesingle{}s). It means that for each pixel location $(x,y)$ in the source image (normally, rectangular), its neighborhood is considered and used to compute the response. In case of a linear filter, it is a weighted sum of pixel values. In case of morphological operations, it is the minimum or maximum values, and so on. The computed response is stored in the destination image at the same location $(x,y)$. It means that the output image will be of the same size as the input image. Normally, the functions support multi-\/channel arrays, in which case every channel is processed independently. Therefore, the output image will also have the same number of channels as the input one. 

Another common feature of the functions and classes described in this section is that, unlike simple arithmetic functions, they need to extrapolate values of some non-\/existing pixels. For example, if you want to smooth an image using a Gaussian $3 \times 3$ filter, then, when processing the left-\/most pixels in each row, you need pixels to the left of them, that is, outside of the image. You can let these pixels be the same as the left-\/most image pixels (\char`\"{}replicated
border\char`\"{} extrapolation method), or assume that all the non-\/existing pixels are zeros (\char`\"{}constant
border\char`\"{} extrapolation method), and so on. Open\+CV enables you to specify the extrapolation method. For details, see cv\+::\+Border\+Types 

\label{group__imgproc__filter_filter_depths}%
\Hypertarget{group__imgproc__filter_filter_depths}%
\paragraph*{Depth combinations}

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Input depth (src.\+depth()) }&\textbf{ Output depth (ddepth)  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Input depth (src.\+depth()) }&\textbf{ Output depth (ddepth)  }\\\cline{1-2}
\endhead
C\+V\+\_\+8U &-\/1/\+C\+V\+\_\+16\+S/\+C\+V\+\_\+32\+F/\+C\+V\+\_\+64F \\\cline{1-2}
C\+V\+\_\+16\+U/\+C\+V\+\_\+16S &-\/1/\+C\+V\+\_\+32\+F/\+C\+V\+\_\+64F \\\cline{1-2}
C\+V\+\_\+32F &-\/1/\+C\+V\+\_\+32\+F/\+C\+V\+\_\+64F \\\cline{1-2}
C\+V\+\_\+64F &-\/1/\+C\+V\+\_\+64F \\\cline{1-2}
\end{longtabu}


\begin{DoxyNote}{Note}
when ddepth=-\/1, the output image will have the same depth as the source. 
\end{DoxyNote}


/$\ast$$\ast$ 

/$\ast$$\ast$ type of morphological operation

imgproc\+\_\+feature 

/$\ast$$\ast$

The function computes and returns the $\texttt{ksize} \times 1$ matrix of Gaussian filter coefficients\+: 

\[G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)},\] 

where $i=0..\texttt{ksize}-1$ and $\alpha$ is the scale factor chosen so that $\sum_i G_i=1$. 

Two of such generated kernels can be passed to sep\+Filter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-\/level Gaussian\+Blur. 
\begin{DoxyParams}{Parameters}
{\em ksize} & Aperture size. It should be odd ( $\texttt{ksize} \mod 2 = 1$ ) and positive. \\
\hline
{\em sigma} & Gaussian standard deviation. If it is non-\/positive, it is computed from ksize as 
\begin{DoxyCode}
sigma = 0.3\(\backslash\)*((ksize-1)\(\backslash\)*0.5 - 1) + 0.8 
\end{DoxyCode}
 . \\
\hline
{\em ktype} & Type of filter coefficients. It can be C\+V\+\_\+32F or C\+V\+\_\+64F . \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}{sep\+Filter2D}, \hyperlink{group__imgproc__filter_ga6e163a3c7af7f53953629e3bc1a4d5ea}{get\+Deriv\+Kernels}, \hyperlink{group__imgproc__filter_ga18af407581ba537b9095d14090cce31a}{get\+Structuring\+Element}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur}
\end{DoxySeeAlso}
imgproc\+\_\+feature 

/$\ast$$\ast$

imgproc\+\_\+misc 

/$\ast$$\ast$

By default, size of the output image is computed as
\begin{DoxyCode}
Size((src.cols+1)/2, (src.rows+1)/2) 
\end{DoxyCode}
 , but in any case, the following conditions should be satisfied\+: 

\[\begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array}\] 

The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel\+: 

\[\frac{1}{256} \begin{bmatrix} 1 & 4 & 6 & 4 & 1 \\ 4 & 16 & 24 & 16 & 4 \\ 6 & 24 & 36 & 24 & 6 \\ 4 & 16 & 24 & 16 & 4 \\ 1 & 4 & 6 & 4 & 1 \end{bmatrix}\] 

Then, it downsamples the image by rejecting even rows and columns. 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image; it has the specified size and the same type as src. \\
\hline
{\em dstsize} & size of the output image. \\
\hline
{\em border\+Type} & Pixel extrapolation method, see cv\+::\+Border\+Types (B\+O\+R\+D\+E\+R\+\_\+\+C\+O\+N\+S\+T\+A\+NT isn\textquotesingle{}t supported)\\
\hline
\end{DoxyParams}


/$\ast$$\ast$

The function implements the filtering stage of meanshift segmentation, that is, the output of the function is the filtered \char`\"{}posterized\char`\"{} image with color gradients and fine-\/grain texture flattened. At every pixel (X,Y) of the input image (or down-\/sized input image, see below) the function executes meanshift iterations, that is, the pixel (X,Y) neighborhood in the joint space-\/color hyperspace is considered\+: 

\[(x,y): X- \texttt{sp} \le x \le X+ \texttt{sp} , Y- \texttt{sp} \le y \le Y+ \texttt{sp} , ||(R,G,B)-(r,g,b)|| \le \texttt{sr}\] 

where (R,G,B) and (r,g,b) are the vectors of color components at (X,Y) and (x,y), respectively (though, the algorithm does not depend on the color space used, so any 3-\/component color space can be used instead). Over the neighborhood the average spatial value (X\textquotesingle{},Y\textquotesingle{}) and average color vector (R\textquotesingle{},G\textquotesingle{},B\textquotesingle{}) are found and they act as the neighborhood center on the next iteration\+: 

\[(X,Y)~(X',Y'), (R,G,B)~(R',G',B').\] 

After the iterations over, the color components of the initial pixel (that is, the pixel from where the iterations started) are set to the final value (average color at the last iteration)\+: 

\[I(X,Y) <- (R*,G*,B*)\] 

When max\+Level $>$ 0, the gaussian pyramid of max\+Level+1 levels is built, and the above procedure is run on the smallest layer first. After that, the results are propagated to the larger layer and the iterations are run again only on those pixels where the layer colors differ by more than sr from the lower-\/resolution layer of the pyramid. That makes boundaries of color regions sharper. Note that the results will be actually different from the ones obtained by running the meanshift procedure on the whole original image (i.\+e. when max\+Level==0). 


\begin{DoxyParams}{Parameters}
{\em src} & The source 8-\/bit, 3-\/channel image. \\
\hline
{\em dst} & The destination image of the same format and the same size as the source. \\
\hline
{\em sp} & The spatial window radius. \\
\hline
{\em sr} & The color window radius. \\
\hline
{\em max\+Level} & Maximum level of the pyramid for the segmentation. \\
\hline
{\em termcrit} & Termination criteria\+: when to stop meanshift iterations. \\
\hline
\end{DoxyParams}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}\label{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}} 
\index{Image Filtering@{Image Filtering}!bilateral\+Filter@{bilateral\+Filter}}
\index{bilateral\+Filter@{bilateral\+Filter}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{bilateral\+Filter()}{bilateralFilter()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bilateral\+Filter (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{d,  }\item[{double}]{sigma\+Color,  }\item[{double}]{sigma\+Space,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Applies the bilateral filter to an image. 

The function applies bilateral filtering to the input image, as described in \href{http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html}{\tt http\+://www.\+dai.\+ed.\+ac.\+uk/\+C\+Vonline/\+L\+O\+C\+A\+L\+\_\+\+C\+O\+P\+I\+E\+S/\+M\+A\+N\+D\+U\+C\+H\+I1/\+Bilateral\+\_\+\+Filtering.\+html} bilateral\+Filter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters. 

{\itshape Sigma values}\+: For simplicity, you can set the 2 sigma values to be the same. If they are small ($<$ 10), the filter will not have much effect, whereas if they are large ($>$ 150), they will have a very strong effect, making the image look \char`\"{}cartoonish\char`\"{}. 

{\itshape Filter size}\+: Large filters (d $>$ 5) are very slow, so it is recommended to use d=5 for real-\/time applications, and perhaps d=9 for offline applications that need heavy noise filtering. 

This filter does not work inplace. 
\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit or floating-\/point, 1-\/channel or 3-\/channel image. \\
\hline
{\em dst} & Destination image of the same size and type as src . \\
\hline
{\em d} & Diameter of each pixel neighborhood that is used during filtering. If it is non-\/positive, it is computed from sigma\+Space. \\
\hline
{\em sigma\+Color} & Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigma\+Space) will be mixed together, resulting in larger areas of semi-\/equal color. \\
\hline
{\em sigma\+Space} & Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigma\+Color ). When d$>$0, it specifies the neighborhood size regardless of sigma\+Space. Otherwise, d is proportional to sigma\+Space. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_gadbbb8985760a3feef02011466803a5a2}\label{group__imgproc__filter_gadbbb8985760a3feef02011466803a5a2}} 
\index{Image Filtering@{Image Filtering}!blend\+Linear@{blend\+Linear}}
\index{blend\+Linear@{blend\+Linear}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{blend\+Linear()}{blendLinear()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blend\+Linear (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src1,  }\item[{@By\+Val Mat}]{src2,  }\item[{@By\+Val Mat}]{weights1,  }\item[{@By\+Val Mat}]{weights2,  }\item[{@By\+Val Mat}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Performs linear blending of two images \mbox{\Hypertarget{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}\label{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}} 
\index{Image Filtering@{Image Filtering}!blur@{blur}}
\index{blur@{blur}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{blur()}{blur()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+blur (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{@By\+Val Size}]{ksize,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Blurs an image using the normalized box filter. 

The function smoothes an image using the kernel\+: 

\[\texttt{K} = \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 & 1 & 1 & \cdots & 1 & 1 \\ 1 & 1 & 1 & \cdots & 1 & 1 \\ \hdotsfor{6} \\ 1 & 1 & 1 & \cdots & 1 & 1 \\ \end{bmatrix}\] 

The call
\begin{DoxyCode}
\hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{blur}(src, dst, ksize, anchor, borderType) 
\end{DoxyCode}
 is equivalent to
\begin{DoxyCode}
 \hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{boxFilter}(src, dst, src.type(),
anchor, \textcolor{keyword}{true}, borderType) 
\end{DoxyCode}
 . 


\begin{DoxyParams}{Parameters}
{\em src} & input image; it can have any number of channels, which are processed independently, but the depth should be C\+V\+\_\+8U, C\+V\+\_\+16U, C\+V\+\_\+16S, C\+V\+\_\+32F or C\+V\+\_\+64F. \\
\hline
{\em dst} & output image of the same size and type as src. \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value Point(-\/1,-\/1) means that the anchor is at the kernel center. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{box\+Filter}, \hyperlink{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}{bilateral\+Filter}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur}, \hyperlink{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}{median\+Blur} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}\label{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}} 
\index{Image Filtering@{Image Filtering}!box\+Filter@{box\+Filter}}
\index{box\+Filter@{box\+Filter}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{box\+Filter()}{boxFilter()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Filter (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{@By\+Val Size}]{ksize,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{normalize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Blurs an image using the box filter. 

The function smoothes an image using the kernel\+: 

\[\texttt{K} = \alpha \begin{bmatrix} 1 & 1 & 1 & \cdots & 1 & 1 \\ 1 & 1 & 1 & \cdots & 1 & 1 \\ \hdotsfor{6} \\ 1 & 1 & 1 & \cdots & 1 & 1 \end{bmatrix}\] 

where 

\[\alpha = \fork{\frac{1}{\texttt{ksize.width*ksize.height}}}{when \texttt{normalize=true}}{1}{otherwise}\] 

Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-\/size windows, use cv\+::integral. 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and type as src. \\
\hline
{\em ddepth} & the output image depth (-\/1 to use src.\+depth()). \\
\hline
{\em ksize} & blurring kernel size. \\
\hline
{\em anchor} & anchor point; default value Point(-\/1,-\/1) means that the anchor is at the kernel center. \\
\hline
{\em normalize} & flag, specifying whether the kernel is normalized by its area or not. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{blur}, \hyperlink{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}{bilateral\+Filter}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur}, \hyperlink{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}{median\+Blur}, integral 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga418b215211fecb0c256c9db02d80dd0e}\label{group__imgproc__filter_ga418b215211fecb0c256c9db02d80dd0e}} 
\index{Image Filtering@{Image Filtering}!build\+Pyramid@{build\+Pyramid}}
\index{build\+Pyramid@{build\+Pyramid}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{build\+Pyramid()}{buildPyramid()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+build\+Pyramid (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat\+Vector}]{dst,  }\item[{int}]{maxlevel,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Constructs the Gaussian pyramid for an image. 

The function constructs a vector of images and builds the Gaussian pyramid by recursively applying pyr\+Down to the previously built pyramid layers, starting from
\begin{DoxyCode}
dst[0]==src 
\end{DoxyCode}
 . 


\begin{DoxyParams}{Parameters}
{\em src} & Source image. Check pyr\+Down for the list of supported types. \\
\hline
{\em dst} & Destination vector of maxlevel+1 images of the same type as src. dst\mbox{[}0\mbox{]} will be the same as src. dst\mbox{[}1\mbox{]} is the next pyramid layer, a smoothed and down-\/sized src, and so on. \\
\hline
{\em maxlevel} & 0-\/based index of the last (the smallest) pyramid layer. It must be non-\/negative. \\
\hline
{\em border\+Type} & Pixel extrapolation method, see cv\+::\+Border\+Types (B\+O\+R\+D\+E\+R\+\_\+\+C\+O\+N\+S\+T\+A\+NT isn\textquotesingle{}t supported) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_ga9184647c04f254c7cfa32edf2cb43bec}\label{group__imgproc__filter_ga9184647c04f254c7cfa32edf2cb43bec}} 
\index{Image Filtering@{Image Filtering}!create\+Generalized\+Hough\+Ballard@{create\+Generalized\+Hough\+Ballard}}
\index{create\+Generalized\+Hough\+Ballard@{create\+Generalized\+Hough\+Ballard}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{create\+Generalized\+Hough\+Ballard()}{createGeneralizedHoughBallard()}}
{\footnotesize\ttfamily static native Generalized\+Hough\+Ballard org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+Generalized\+Hough\+Ballard (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Ballard, D.\+H. (1981). Generalizing the Hough transform to detect arbitrary shapes. Pattern Recognition 13 (2)\+: 111-\/122. Detects position only without traslation and rotation \mbox{\Hypertarget{group__imgproc__filter_ga5b2d07c2bc26dfd8aa2daeae1b3adfac}\label{group__imgproc__filter_ga5b2d07c2bc26dfd8aa2daeae1b3adfac}} 
\index{Image Filtering@{Image Filtering}!create\+Generalized\+Hough\+Guil@{create\+Generalized\+Hough\+Guil}}
\index{create\+Generalized\+Hough\+Guil@{create\+Generalized\+Hough\+Guil}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{create\+Generalized\+Hough\+Guil()}{createGeneralizedHoughGuil()}}
{\footnotesize\ttfamily static native Generalized\+Hough\+Guil org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+create\+Generalized\+Hough\+Guil (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Guil, N., González-\/\+Linares, J.\+M. and Zapata, E.\+L. (1999). Bidimensional shape detection using an invariant approach. Pattern Recognition 32 (6)\+: 1025-\/1038. Detects position, traslation and rotation \mbox{\Hypertarget{group__imgproc__filter_ga8c0cbcc8dd271aada560698924d19cb2}\label{group__imgproc__filter_ga8c0cbcc8dd271aada560698924d19cb2}} 
\index{Image Filtering@{Image Filtering}!erode@{erode}}
\index{erode@{erode}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{erode()}{erode()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+erode (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{@By\+Val Mat}]{kernel,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor,  }\item[{int}]{iterations,  }\item[{int}]{border\+Type,  }\item[{@Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Scalar(cv\+::morphology\+Default\+Border\+Value())\char`\"{}) Scalar}]{border\+Value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Erodes an image by using a specific structuring element. 

The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken\+: 

\[\texttt{dst} (x,y) = \min _{(x',y'): \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y')\] 

The function supports the in-\/place mode. Erosion can be applied several ( iterations ) times. In case of multi-\/channel images, each channel is processed independently. 


\begin{DoxyParams}{Parameters}
{\em src} & input image; the number of channels can be arbitrary, but the depth should be one of C\+V\+\_\+8U, C\+V\+\_\+16U, C\+V\+\_\+16S, C\+V\+\_\+32F or C\+V\+\_\+64F. \\
\hline
{\em dst} & output image of the same size and type as src. \\
\hline
{\em kernel} & structuring element used for erosion; if
\begin{DoxyCode}
element=Mat() 
\end{DoxyCode}
 , a
\begin{DoxyCode}
3 x 3 
\end{DoxyCode}
 rectangular structuring element is used. Kernel can be created using get\+Structuring\+Element. \\
\hline
{\em anchor} & position of the anchor within the element; default value (-\/1, -\/1) means that the anchor is at the element center. \\
\hline
{\em iterations} & number of times erosion is applied. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
{\em border\+Value} & border value in case of a constant border \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
dilate, morphology\+Ex, \hyperlink{group__imgproc__filter_ga18af407581ba537b9095d14090cce31a}{get\+Structuring\+Element} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}\label{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}} 
\index{Image Filtering@{Image Filtering}!filter2D@{filter2D}}
\index{filter2D@{filter2D}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{filter2\+D()}{filter2D()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+filter2D (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{@By\+Val Mat}]{kernel,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Convolves an image with the kernel. 

The function applies an arbitrary linear filter to an image. In-\/place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode. 

The function does actually compute correlation, not the convolution\+: 

\[\texttt{dst} (x,y) = \sum _{ \stackrel{0\leq x' < \texttt{kernel.cols},}{0\leq y' < \texttt{kernel.rows}} } \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} )\] 

That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using cv\+::flip and set the new anchor to
\begin{DoxyCode}
 (kernel.cols - anchor.x - 1, kernel.rows -
anchor.y - 1) 
\end{DoxyCode}
 . 

The function uses the D\+F\+T-\/based algorithm in case of sufficiently large kernels ($\sim$
\begin{DoxyCode}
11 x 11 
\end{DoxyCode}
 or larger) and the direct algorithm for small kernels. 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as src. \\
\hline
{\em ddepth} & desired depth of the destination image, see \hyperlink{group__imgproc__filter_filter_depths}{combinations} \\
\hline
{\em kernel} & convolution kernel (or rather a correlation kernel), a single-\/channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually. \\
\hline
{\em anchor} & anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-\/1,-\/1) means that the anchor is at the kernel center. \\
\hline
{\em delta} & optional value added to the filtered pixels before storing them in dst. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}{sep\+Filter2D}, dft, \hyperlink{group__imgproc__object_ga9a21de5c468f2b954413017382a99d29}{match\+Template} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}\label{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}} 
\index{Image Filtering@{Image Filtering}!Gaussian\+Blur@{Gaussian\+Blur}}
\index{Gaussian\+Blur@{Gaussian\+Blur}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{Gaussian\+Blur()}{GaussianBlur()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Gaussian\+Blur (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{@By\+Val Size}]{ksize,  }\item[{double}]{sigmaX,  }\item[{double}]{sigmaY,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Blurs an image using a Gaussian filter. 

The function convolves the source image with the specified Gaussian kernel. In-\/place filtering is supported. 


\begin{DoxyParams}{Parameters}
{\em src} & input image; the image can have any number of channels, which are processed independently, but the depth should be C\+V\+\_\+8U, C\+V\+\_\+16U, C\+V\+\_\+16S, C\+V\+\_\+32F or C\+V\+\_\+64F. \\
\hline
{\em dst} & output image of the same size and type as src. \\
\hline
{\em ksize} & Gaussian kernel size. ksize.\+width and ksize.\+height can differ but they both must be positive and odd. Or, they can be zero\textquotesingle{}s and then they are computed from sigma. \\
\hline
{\em sigmaX} & Gaussian kernel standard deviation in X direction. \\
\hline
{\em sigmaY} & Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.\+width and ksize.\+height, respectively (see cv\+::get\+Gaussian\+Kernel for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}{sep\+Filter2D}, \hyperlink{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}{filter2D}, \hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{blur}, \hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{box\+Filter}, \hyperlink{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}{bilateral\+Filter}, \hyperlink{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}{median\+Blur} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga6e163a3c7af7f53953629e3bc1a4d5ea}\label{group__imgproc__filter_ga6e163a3c7af7f53953629e3bc1a4d5ea}} 
\index{Image Filtering@{Image Filtering}!get\+Deriv\+Kernels@{get\+Deriv\+Kernels}}
\index{get\+Deriv\+Kernels@{get\+Deriv\+Kernels}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{get\+Deriv\+Kernels()}{getDerivKernels()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Deriv\+Kernels (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{kx,  }\item[{@By\+Val Mat}]{ky,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{normalize,  }\item[{int}]{ktype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns filter coefficients for computing spatial image derivatives. 

The function computes and returns the filter coefficients for spatial image derivatives. When 
\begin{DoxyCode}
ksize=\hyperlink{group__imgproc__c_gad680d8093fc7352b21881b08002d7698}{CV\_SCHARR} 
\end{DoxyCode}
 , the Scharr $3 \times 3$ kernels are generated (see cv\+::\+Scharr). Otherwise, Sobel kernels are generated (see cv\+::\+Sobel). The filters are normally passed to sep\+Filter2D or to 


\begin{DoxyParams}{Parameters}
{\em kx} & Output matrix of row filter coefficients. It has the type ktype . \\
\hline
{\em ky} & Output matrix of column filter coefficients. It has the type ktype . \\
\hline
{\em dx} & Derivative order in respect of x. \\
\hline
{\em dy} & Derivative order in respect of y. \\
\hline
{\em ksize} & Aperture size. It can be C\+V\+\_\+\+S\+C\+H\+A\+RR, 1, 3, 5, or 7. \\
\hline
{\em normalize} & Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator $=2^{ksize*2-dx-dy-2}$. If you are going to filter floating-\/point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-\/bit image, store the results in a 16-\/bit image, and wish to preserve all the fractional bits, you may want to set normalize=false . \\
\hline
{\em ktype} & Type of filter coefficients. It can be C\+V\+\_\+32f or C\+V\+\_\+64F . \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_ga8c30992daccc2467cea3d7d2f016a9ab}\label{group__imgproc__filter_ga8c30992daccc2467cea3d7d2f016a9ab}} 
\index{Image Filtering@{Image Filtering}!get\+Gabor\+Kernel@{get\+Gabor\+Kernel}}
\index{get\+Gabor\+Kernel@{get\+Gabor\+Kernel}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{get\+Gabor\+Kernel()}{getGaborKernel()}}
{\footnotesize\ttfamily static native Mat org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Gabor\+Kernel (\begin{DoxyParamCaption}\item[{@By\+Val Size}]{ksize,  }\item[{double}]{sigma,  }\item[{double}]{theta,  }\item[{double}]{lambd,  }\item[{double}]{gamma,  }\item[{double}]{psi,  }\item[{int}]{ktype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns Gabor filter coefficients. 

For more details about gabor filter equations and parameters, see\+: \href{http://en.wikipedia.org/wiki/Gabor_filter}{\tt Gabor Filter}. 


\begin{DoxyParams}{Parameters}
{\em ksize} & Size of the filter returned. \\
\hline
{\em sigma} & Standard deviation of the gaussian envelope. \\
\hline
{\em theta} & Orientation of the normal to the parallel stripes of a Gabor function. \\
\hline
{\em lambd} & Wavelength of the sinusoidal factor. \\
\hline
{\em gamma} & Spatial aspect ratio. \\
\hline
{\em psi} & Phase offset. \\
\hline
{\em ktype} & Type of filter coefficients. It can be C\+V\+\_\+32F or C\+V\+\_\+64F . \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_ga18af407581ba537b9095d14090cce31a}\label{group__imgproc__filter_ga18af407581ba537b9095d14090cce31a}} 
\index{Image Filtering@{Image Filtering}!get\+Structuring\+Element@{get\+Structuring\+Element}}
\index{get\+Structuring\+Element@{get\+Structuring\+Element}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{get\+Structuring\+Element()}{getStructuringElement()}}
{\footnotesize\ttfamily static native Mat org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+get\+Structuring\+Element (\begin{DoxyParamCaption}\item[{int}]{shape,  }\item[{@By\+Val Size}]{ksize,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Returns a structuring element of the specified size and shape for morphological operations. 

The function constructs and returns the structuring element that can be further passed to cv\+::erode, cv\+::dilate or cv\+::morphology\+Ex. But you can also construct an arbitrary binary mask yourself and use it as the structuring element. 


\begin{DoxyParams}{Parameters}
{\em shape} & Element shape that could be one of cv\+::\+Morph\+Shapes \\
\hline
{\em ksize} & Size of the structuring element. \\
\hline
{\em anchor} & Anchor position within the element. The default value $(-1, -1)$ means that the anchor is at the center. Note that only the shape of a cross-\/shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_ga223106fa434e6e5dee1974eab81bbf26}\label{group__imgproc__filter_ga223106fa434e6e5dee1974eab81bbf26}} 
\index{Image Filtering@{Image Filtering}!Laplacian@{Laplacian}}
\index{Laplacian@{Laplacian}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{Laplacian()}{Laplacian()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Laplacian (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the Laplacian of an image. 

The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator\+: 

\[\texttt{dst} = \Delta \texttt{src} = \frac{\partial^2 \texttt{src}}{\partial x^2} + \frac{\partial^2 \texttt{src}}{\partial y^2}\] 

This is done when
\begin{DoxyCode}
ksize > 1 
\end{DoxyCode}
 . When
\begin{DoxyCode}
ksize == 1 
\end{DoxyCode}
 , the Laplacian is computed by filtering the image with the following $3 \times 3$ aperture\+: 

\[\vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0}\] 


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as src . \\
\hline
{\em ddepth} & Desired depth of the destination image. \\
\hline
{\em ksize} & Aperture size used to compute the second-\/derivative filters. See get\+Deriv\+Kernels for details. The size must be positive and odd. \\
\hline
{\em scale} & Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See get\+Deriv\+Kernels for details. \\
\hline
{\em delta} & Optional delta value that is added to the results prior to storing them in dst . \\
\hline
{\em border\+Type} & Pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{Sobel}, \hyperlink{group__imgproc__filter_gabd4c276a8055604be5e13e061eee74a1}{Scharr} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}\label{group__imgproc__filter_ga6a7fd362c0b073cd051d4fcb7a9904c9}} 
\index{Image Filtering@{Image Filtering}!median\+Blur@{median\+Blur}}
\index{median\+Blur@{median\+Blur}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{median\+Blur()}{medianBlur()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+median\+Blur (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ksize }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Blurs an image using the median filter. 

The function smoothes an image using the median filter with the $\texttt{ksize} \times \texttt{ksize}$ aperture. Each channel of a multi-\/channel image is processed independently. In-\/place operation is supported. 

\begin{DoxyNote}{Note}
The median filter uses B\+O\+R\+D\+E\+R\+\_\+\+R\+E\+P\+L\+I\+C\+A\+TE internally to cope with border pixels, see cv\+::\+Border\+Types 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em src} & input 1-\/, 3-\/, or 4-\/channel image; when ksize is 3 or 5, the image depth should be C\+V\+\_\+8U, C\+V\+\_\+16U, or C\+V\+\_\+32F, for larger aperture sizes, it can only be C\+V\+\_\+8U. \\
\hline
{\em dst} & destination array of the same size and type as src. \\
\hline
{\em ksize} & aperture linear size; it must be odd and greater than 1, for example\+: 3, 5, 7 ... \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga15d81db5deb10dd5c7f6ff4b6193a644}{bilateral\+Filter}, \hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{blur}, \hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{box\+Filter}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_gaa77a7ec53d115ff76de4c8797d6d83f7}\label{group__imgproc__filter_gaa77a7ec53d115ff76de4c8797d6d83f7}} 
\index{Image Filtering@{Image Filtering}!morphology\+Default\+Border\+Value@{morphology\+Default\+Border\+Value}}
\index{morphology\+Default\+Border\+Value@{morphology\+Default\+Border\+Value}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{morphology\+Default\+Border\+Value()}{morphologyDefaultBorderValue()}}
{\footnotesize\ttfamily static native Scalar org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+morphology\+Default\+Border\+Value (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

returns \char`\"{}magic\char`\"{} border value for erosion and dilation. It is automatically transformed to Scalar\+::all(-\/\+D\+B\+L\+\_\+\+M\+AX) for dilation. \mbox{\Hypertarget{group__imgproc__filter_ga3fc37612b218d8cee2f4b099a8d0a2aa}\label{group__imgproc__filter_ga3fc37612b218d8cee2f4b099a8d0a2aa}} 
\index{Image Filtering@{Image Filtering}!pyr\+Up@{pyr\+Up}}
\index{pyr\+Up@{pyr\+Up}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{pyr\+Up()}{pyrUp()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+pyr\+Up (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{@Const @By\+Ref(null\+Value=\char`\"{}cv\+::\+Size()\char`\"{}) Size}]{dstsize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Upsamples an image and then blurs it. 

By default, size of the output image is computed as
\begin{DoxyCode}
Size(src.cols\(\backslash\)*2, (src.rows\(\backslash\)*2) 
\end{DoxyCode}
 , but in any case, the following conditions should be satisfied\+: 

\[\begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq ( \texttt{dstsize.width} \mod 2) \\ | \texttt{dstsize.height} -src.rows*2| \leq ( \texttt{dstsize.height} \mod 2) \end{array}\] 

The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyr\+Down multiplied by 4. 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image. It has the specified size and the same type as src . \\
\hline
{\em dstsize} & size of the output image. \\
\hline
{\em border\+Type} & Pixel extrapolation method, see cv\+::\+Border\+Types (only B\+O\+R\+D\+E\+R\+\_\+\+D\+E\+F\+A\+U\+LT is supported) \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__filter_gabd4c276a8055604be5e13e061eee74a1}\label{group__imgproc__filter_gabd4c276a8055604be5e13e061eee74a1}} 
\index{Image Filtering@{Image Filtering}!Scharr@{Scharr}}
\index{Scharr@{Scharr}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{Scharr()}{Scharr()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Scharr (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the first x-\/ or y-\/ image derivative using Scharr operator. 

The function computes the first x-\/ or y-\/ spatial image derivative using the Scharr operator. The call 

\[\texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)}\] 

is equivalent to 

\[\texttt{Sobel(src, dst, ddepth, dx, dy, CV\_SCHARR, scale, delta, borderType)} .\] 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as src. \\
\hline
{\em ddepth} & output image depth, see \hyperlink{group__imgproc__filter_filter_depths}{combinations} \\
\hline
{\em dx} & order of the derivative x. \\
\hline
{\em dy} & order of the derivative y. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see get\+Deriv\+Kernels for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in dst. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
cart\+To\+Polar 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}\label{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}} 
\index{Image Filtering@{Image Filtering}!sep\+Filter2D@{sep\+Filter2D}}
\index{sep\+Filter2D@{sep\+Filter2D}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{sep\+Filter2\+D()}{sepFilter2D()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sep\+Filter2D (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{@By\+Val Mat}]{kernelX,  }\item[{@By\+Val Mat}]{kernelY,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1,-\/1)\char`\"{}) Point}]{anchor,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Applies a separable linear filter to an image. 

The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst . 


\begin{DoxyParams}{Parameters}
{\em src} & Source image. \\
\hline
{\em dst} & Destination image of the same size and the same number of channels as src . \\
\hline
{\em ddepth} & Destination image depth, see \hyperlink{group__imgproc__filter_filter_depths}{combinations} \\
\hline
{\em kernelX} & Coefficients for filtering each row. \\
\hline
{\em kernelY} & Coefficients for filtering each column. \\
\hline
{\em anchor} & Anchor position within the kernel. The default value $(-1,-1)$ means that the anchor is at the kernel center. \\
\hline
{\em delta} & Value added to the filtered results before storing them. \\
\hline
{\em border\+Type} & Pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}{filter2D}, \hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{Sobel}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur}, \hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{box\+Filter}, \hyperlink{group__imgproc__filter_ga2878e087c0294ad9e5f1996c07b303b4}{blur} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}\label{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}} 
\index{Image Filtering@{Image Filtering}!Sobel@{Sobel}}
\index{Sobel@{Sobel}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{Sobel()}{Sobel()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Sobel (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst,  }\item[{int}]{ddepth,  }\item[{int}]{dx,  }\item[{int}]{dy,  }\item[{int}]{ksize,  }\item[{double}]{scale,  }\item[{double}]{delta,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator. 

In all cases except one, the $\texttt{ksize} \times \texttt{ksize}$ separable kernel is used to calculate the derivative. When $\texttt{ksize = 1}$, the $3 \times 1$ or $1 \times 3$ kernel is used (that is, no Gaussian smoothing is done).
\begin{DoxyCode}
ksize = 1 
\end{DoxyCode}
 can only be used for the first or the second x-\/ or y-\/ derivatives. 

There is also the special value
\begin{DoxyCode}
ksize = \hyperlink{group__imgproc__c_gad680d8093fc7352b21881b08002d7698}{CV\_SCHARR} (-1) 
\end{DoxyCode}
 that corresponds to the $3\times3$ Scharr filter that may give more accurate results than the $3\times3$ Sobel. The Scharr aperture is 

\[\vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3}\] 

for the x-\/derivative, or transposed for the y-\/derivative. 

The function calculates an image derivative by convolving the image with the appropriate kernel\+: 

\[\texttt{dst} = \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}}\] 

The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x-\/ or y-\/ image derivative. The first case corresponds to a kernel of\+: 

\[\vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1}\] 

The second case corresponds to a kernel of\+: 

\[\vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1}\] 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dst} & output image of the same size and the same number of channels as src . \\
\hline
{\em ddepth} & output image depth, see \hyperlink{group__imgproc__filter_filter_depths}{combinations}; in the case of 8-\/bit input images it will result in truncated derivatives. \\
\hline
{\em dx} & order of the derivative x. \\
\hline
{\em dy} & order of the derivative y. \\
\hline
{\em ksize} & size of the extended Sobel kernel; it must be 1, 3, 5, or 7. \\
\hline
{\em scale} & optional scale factor for the computed derivative values; by default, no scaling is applied (see cv\+::get\+Deriv\+Kernels for details). \\
\hline
{\em delta} & optional delta value that is added to the results prior to storing them in dst. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_gabd4c276a8055604be5e13e061eee74a1}{Scharr}, \hyperlink{group__imgproc__filter_ga223106fa434e6e5dee1974eab81bbf26}{Laplacian}, \hyperlink{group__imgproc__filter_ga716654f3d25206913e265bf388fd83d0}{sep\+Filter2D}, \hyperlink{group__imgproc__filter_gac272007b4c23c22cf0fd246522a2a34b}{filter2D}, \hyperlink{group__imgproc__filter_gaf8f0c37e9b9c420a8edfc2753c8fe966}{Gaussian\+Blur}, cart\+To\+Polar 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_ga9263e9262b1d9a29e4dc3180d4ee2683}\label{group__imgproc__filter_ga9263e9262b1d9a29e4dc3180d4ee2683}} 
\index{Image Filtering@{Image Filtering}!spatial\+Gradient@{spatial\+Gradient}}
\index{spatial\+Gradient@{spatial\+Gradient}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{spatial\+Gradient()}{spatialGradient()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+spatial\+Gradient (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dx,  }\item[{@By\+Val Mat}]{dy,  }\item[{int}]{ksize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the first order image derivative in both x and y using a Sobel operator. 

Equivalent to calling\+: 


\begin{DoxyPre}
\begin{DoxyCode}
\hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{Sobel}( src, dx, CV\_16SC1, 1, 0, 3 );
\hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{Sobel}( src, dy, CV\_16SC1, 0, 1, 3 );
\end{DoxyCode}
 \end{DoxyPre}
 


\begin{DoxyParams}{Parameters}
{\em src} & input image. \\
\hline
{\em dx} & output image with first-\/order derivative in x. \\
\hline
{\em dy} & output image with first-\/order derivative in y. \\
\hline
{\em ksize} & size of Sobel kernel. It must be 3. \\
\hline
{\em border\+Type} & pixel extrapolation method, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga99eaf057a0aad8f1ba5bc04ca0defe15}{Sobel} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__filter_gac3bb5f90c81da13be223978755c103e2}\label{group__imgproc__filter_gac3bb5f90c81da13be223978755c103e2}} 
\index{Image Filtering@{Image Filtering}!sqr\+Box\+Filter@{sqr\+Box\+Filter}}
\index{sqr\+Box\+Filter@{sqr\+Box\+Filter}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{sqr\+Box\+Filter()}{sqrBoxFilter()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+sqr\+Box\+Filter (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{\+\_\+src,  }\item[{@By\+Val Mat}]{\+\_\+dst,  }\item[{int}]{ddepth,  }\item[{@By\+Val Size}]{ksize,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Point(-\/1, -\/1)\char`\"{}) Point}]{anchor,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{normalize,  }\item[{int}]{border\+Type }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the normalized sum of squares of the pixel values overlapping the filter. 

For every pixel $ (x, y) $ in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel $ (x, y) $. 

The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel. 


\begin{DoxyParams}{Parameters}
{\em \+\_\+src} & input image \\
\hline
{\em \+\_\+dst} & output image of the same size and type as \+\_\+src \\
\hline
{\em ddepth} & the output image depth (-\/1 to use src.\+depth()) \\
\hline
{\em ksize} & kernel size \\
\hline
{\em anchor} & kernel anchor point. The default value of Point(-\/1, -\/1) denotes that the anchor is at the kernel center. \\
\hline
{\em normalize} & flag, specifying whether the kernel is to be normalized by it\textquotesingle{}s area or not. \\
\hline
{\em border\+Type} & border mode used to extrapolate pixels outside of the image, see cv\+::\+Border\+Types \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__filter_ga479aa13dd62a69ab5b1a1eac3324ab23}{box\+Filter} 
\end{DoxySeeAlso}


\subsection{Variable Documentation}
\mbox{\Hypertarget{group__imgproc__filter_ga0f22b83b4ad2465132087b8d059a2101}\label{group__imgproc__filter_ga0f22b83b4ad2465132087b8d059a2101}} 
\index{Image Filtering@{Image Filtering}!M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE@{M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE}}
\index{M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE@{M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE}{MORPH\_ERODE}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+M\+O\+R\+P\+H\+\_\+\+E\+R\+O\+DE = 0\hspace{0.3cm}{\ttfamily [static]}}

enum cv\+::\+Morph\+Types see cv\+::erode \mbox{\Hypertarget{group__imgproc__filter_ga8380bc8d565b30f65b81f16987e9edeb}\label{group__imgproc__filter_ga8380bc8d565b30f65b81f16987e9edeb}} 
\index{Image Filtering@{Image Filtering}!M\+O\+R\+P\+H\+\_\+\+R\+E\+CT@{M\+O\+R\+P\+H\+\_\+\+R\+E\+CT}}
\index{M\+O\+R\+P\+H\+\_\+\+R\+E\+CT@{M\+O\+R\+P\+H\+\_\+\+R\+E\+CT}!Image Filtering@{Image Filtering}}
\subsubsection{\texorpdfstring{M\+O\+R\+P\+H\+\_\+\+R\+E\+CT}{MORPH\_RECT}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+M\+O\+R\+P\+H\+\_\+\+R\+E\+CT = 0\hspace{0.3cm}{\ttfamily [static]}}

shape of the structuring element enum cv\+::\+Morph\+Shapes a rectangular structuring element\+: \[E_{ij}=1\] 