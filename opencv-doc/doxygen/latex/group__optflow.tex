\hypertarget{group__optflow}{}\section{Optical Flow Algorithms}
\label{group__optflow}\index{Optical Flow Algorithms@{Optical Flow Algorithms}}


Updates the motion history image by a moving silhouette.  


\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+Variational\+Refinement}
\begin{DoxyCompactList}\small\item\em Variational optical flow refinement. \end{DoxyCompactList}\item 
class {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+D\+I\+S\+Optical\+Flow}
\begin{DoxyCompactList}\small\item\em D\+IS optical flow algorithm. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__optflow_gac3566ed874933bad6b2825c00f37bfac}\label{group__optflow_gac3566ed874933bad6b2825c00f37bfac}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+SF} ( @By\+Val Mat from, @By\+Val Mat to, @By\+Val Mat flow, int layers, int averaging\+\_\+block\+\_\+size, int max\+\_\+flow)
\item 
\mbox{\Hypertarget{group__optflow_ga29dd3fec5011cf1d5c7fa051ff1c38ad}\label{group__optflow_ga29dd3fec5011cf1d5c7fa051ff1c38ad}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+SF} ( @By\+Val U\+Mat from, @By\+Val U\+Mat to, @By\+Val U\+Mat flow, int layers, int averaging\+\_\+block\+\_\+size, int max\+\_\+flow)
\item 
static native void \hyperlink{group__optflow_ga76902de70b538596bed7e39b7777384d}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+SF} ( @By\+Val Mat from, @By\+Val Mat to, @By\+Val Mat flow, int layers, int averaging\+\_\+block\+\_\+size, int max\+\_\+flow, double sigma\+\_\+dist, double sigma\+\_\+color, int postprocess\+\_\+window, double sigma\+\_\+dist\+\_\+fix, double sigma\+\_\+color\+\_\+fix, double occ\+\_\+thr, int upscale\+\_\+averaging\+\_\+radius, double upscale\+\_\+sigma\+\_\+dist, double upscale\+\_\+sigma\+\_\+color, double speed\+\_\+up\+\_\+thr)
\begin{DoxyCompactList}\small\item\em Calculate an optical flow using \char`\"{}\+Simple\+Flow\char`\"{} algorithm. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_gaf778fa8a2d9e5d336c9e66f1f6577271}\label{group__optflow_gaf778fa8a2d9e5d336c9e66f1f6577271}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+SF} ( @By\+Val U\+Mat from, @By\+Val U\+Mat to, @By\+Val U\+Mat flow, int layers, int averaging\+\_\+block\+\_\+size, int max\+\_\+flow, double sigma\+\_\+dist, double sigma\+\_\+color, int postprocess\+\_\+window, double sigma\+\_\+dist\+\_\+fix, double sigma\+\_\+color\+\_\+fix, double occ\+\_\+thr, int upscale\+\_\+averaging\+\_\+radius, double upscale\+\_\+sigma\+\_\+dist, double upscale\+\_\+sigma\+\_\+color, double speed\+\_\+up\+\_\+thr)
\item 
static native void \hyperlink{group__optflow_gab202f6c782e9356cf2a96620732785a9}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+Sparse\+To\+Dense} ( @By\+Val Mat from, @By\+Val Mat to, @By\+Val Mat flow, int grid\+\_\+step, int k, float sigma, @Cast(\char`\"{}bool\char`\"{}) boolean use\+\_\+post\+\_\+proc, float fgs\+\_\+lambda, float fgs\+\_\+sigma)
\begin{DoxyCompactList}\small\item\em Fast dense optical flow based on Pyr\+LK sparse matches interpolation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_ga232800d9e04e7d3d9d6412b7bf695e11}\label{group__optflow_ga232800d9e04e7d3d9d6412b7bf695e11}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+Sparse\+To\+Dense} ( @By\+Val Mat from, @By\+Val Mat to, @By\+Val Mat flow)
\item 
\mbox{\Hypertarget{group__optflow_ga1e7e5b5bb682863c28da8ee4375de834}\label{group__optflow_ga1e7e5b5bb682863c28da8ee4375de834}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+Sparse\+To\+Dense} ( @By\+Val U\+Mat from, @By\+Val U\+Mat to, @By\+Val U\+Mat flow, int grid\+\_\+step, int k, float sigma, @Cast(\char`\"{}bool\char`\"{}) boolean use\+\_\+post\+\_\+proc, float fgs\+\_\+lambda, float fgs\+\_\+sigma)
\item 
\mbox{\Hypertarget{group__optflow_gaad1826bcce1245d87fd9fb9f65b508d1}\label{group__optflow_gaad1826bcce1245d87fd9fb9f65b508d1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+Sparse\+To\+Dense} ( @By\+Val U\+Mat from, @By\+Val U\+Mat to, @By\+Val U\+Mat flow)
\item 
static native Mat \hyperlink{group__optflow_ga8adc9b054c1518ab41c20d8ada51b9b7}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+read\+Optical\+Flow} ( @Str Byte\+Pointer path)
\begin{DoxyCompactList}\small\item\em Read a .flo file. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_ga4b2573f3c0a1dd3b91b11e315791bd2f}\label{group__optflow_ga4b2573f3c0a1dd3b91b11e315791bd2f}} 
static native Mat {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+read\+Optical\+Flow} ( @Str String path)
\item 
static native boolean \hyperlink{group__optflow_ga41bea8c25211f346782adfb40129e96e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+write\+Optical\+Flow} ( @Str Byte\+Pointer path, @By\+Val Mat flow)
\begin{DoxyCompactList}\small\item\em Write a .flo to disk. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_ga2ce63b6527e15bb4e67e704210c41144}\label{group__optflow_ga2ce63b6527e15bb4e67e704210c41144}} 
static native boolean {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+write\+Optical\+Flow} ( @Str String path, @By\+Val Mat flow)
\item 
\mbox{\Hypertarget{group__optflow_ga2f16aacf0d7c356065b7051bc466fc9d}\label{group__optflow_ga2f16aacf0d7c356065b7051bc466fc9d}} 
static native boolean {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+write\+Optical\+Flow} ( @Str Byte\+Pointer path, @By\+Val U\+Mat flow)
\item 
\mbox{\Hypertarget{group__optflow_ga1aaf6ebff608935e1cfe219216e8196b}\label{group__optflow_ga1aaf6ebff608935e1cfe219216e8196b}} 
static native boolean {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+write\+Optical\+Flow} ( @Str String path, @By\+Val U\+Mat flow)
\item 
\mbox{\Hypertarget{group__optflow_ga6d7be52a57f2105050c7a7039ab1af2e}\label{group__optflow_ga6d7be52a57f2105050c7a7039ab1af2e}} 
static native Variational\+Refinement \hyperlink{group__optflow_ga6d7be52a57f2105050c7a7039ab1af2e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Variational\+Flow\+Refinement} ()
\begin{DoxyCompactList}\small\item\em Creates an instance of Variational\+Refinement. \end{DoxyCompactList}\item 
static native Dense\+Optical\+Flow \hyperlink{group__optflow_ga27f2a261b7f69f4eaaf2aa2552943a1a}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Deep\+Flow} ()
\begin{DoxyCompactList}\small\item\em Deep\+Flow optical flow algorithm implementation. \end{DoxyCompactList}\item 
static native Dense\+Optical\+Flow \hyperlink{group__optflow_gace52b781a9780c4c9a20951a2bec314d}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Simple\+Flow} ()
\item 
static native Dense\+Optical\+Flow \hyperlink{group__optflow_gabd230cc626a64515ec35ac6c6c7fc099}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Farneback} ()
\item 
static native Dense\+Optical\+Flow \hyperlink{group__optflow_ga2033e98010d9ac8b150503a107601946}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense} ()
\item 
static native D\+I\+S\+Optical\+Flow \hyperlink{group__optflow_gac107283f5dba4f320df3d9894aad537b}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+D\+IS} (int preset)
\begin{DoxyCompactList}\small\item\em Creates an instance of D\+I\+S\+Optical\+Flow. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_ga72c0f64b880a5a0a84db8ccf55ce4496}\label{group__optflow_ga72c0f64b880a5a0a84db8ccf55ce4496}} 
static native D\+I\+S\+Optical\+Flow {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+D\+IS} ()
\item 
\mbox{\Hypertarget{group__optflow_ga01b6daae8e4bd5db89270056d32f62f6}\label{group__optflow_ga01b6daae8e4bd5db89270056d32f62f6}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+update\+Motion\+History} ( @By\+Val Mat silhouette, @By\+Val Mat mhi, double timestamp, double duration)
\item 
\mbox{\Hypertarget{group__optflow_ga66502f64fc6246523b1b8c8ccf8f42fb}\label{group__optflow_ga66502f64fc6246523b1b8c8ccf8f42fb}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+update\+Motion\+History} ( @By\+Val U\+Mat silhouette, @By\+Val U\+Mat mhi, double timestamp, double duration)
\item 
static native void \hyperlink{group__optflow_ga1df8e7b81e72fc2df163a156ec07b5ed}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Motion\+Gradient} ( @By\+Val Mat mhi, @By\+Val Mat mask, @By\+Val Mat orientation, double delta1, double delta2, int aperture\+Size)
\begin{DoxyCompactList}\small\item\em Calculates a gradient orientation of a motion history image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_gad4627dc7a9285cb61e098920781f78d9}\label{group__optflow_gad4627dc7a9285cb61e098920781f78d9}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Motion\+Gradient} ( @By\+Val Mat mhi, @By\+Val Mat mask, @By\+Val Mat orientation, double delta1, double delta2)
\item 
\mbox{\Hypertarget{group__optflow_ga6ac164310092a6d2ecec7356e0bdd88d}\label{group__optflow_ga6ac164310092a6d2ecec7356e0bdd88d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Motion\+Gradient} ( @By\+Val U\+Mat mhi, @By\+Val U\+Mat mask, @By\+Val U\+Mat orientation, double delta1, double delta2, int aperture\+Size)
\item 
\mbox{\Hypertarget{group__optflow_ga55f1d6817b88e79e4f9f46014b361ea0}\label{group__optflow_ga55f1d6817b88e79e4f9f46014b361ea0}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Motion\+Gradient} ( @By\+Val U\+Mat mhi, @By\+Val U\+Mat mask, @By\+Val U\+Mat orientation, double delta1, double delta2)
\item 
static native double \hyperlink{group__optflow_gae09be23e6ebae54e6dad95914a82282d}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Global\+Orientation} ( @By\+Val Mat orientation, @By\+Val Mat mask, @By\+Val Mat mhi, double timestamp, double duration)
\begin{DoxyCompactList}\small\item\em Calculates a global motion orientation in a selected region. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_ga2b0fa162d7e97fc6d8d5c743eb9f7e76}\label{group__optflow_ga2b0fa162d7e97fc6d8d5c743eb9f7e76}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Global\+Orientation} ( @By\+Val U\+Mat orientation, @By\+Val U\+Mat mask, @By\+Val U\+Mat mhi, double timestamp, double duration)
\item 
static native void \hyperlink{group__optflow_gad1ff5ca68f3f39b0547c8d249b99185b}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+segment\+Motion} ( @By\+Val Mat mhi, @By\+Val Mat segmask, @By\+Ref Rect\+Vector bounding\+Rects, double timestamp, double seg\+Thresh)
\begin{DoxyCompactList}\small\item\em Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand). \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__optflow_gaf6c40ad0d4b0f8ce55f6b081001cae94}\label{group__optflow_gaf6c40ad0d4b0f8ce55f6b081001cae94}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+segment\+Motion} ( @By\+Val U\+Mat mhi, @By\+Val U\+Mat segmask, @By\+Ref Rect\+Vector bounding\+Rects, double timestamp, double seg\+Thresh)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Updates the motion history image by a moving silhouette. 

Dense optical flow algorithms compute motion for each point\+: 


\begin{DoxyItemize}
\item cv\+::optflow\+::calc\+Optical\+Flow\+SF
\item cv\+::optflow\+::create\+Opt\+Flow\+\_\+\+Deep\+Flow 
\end{DoxyItemize}

Motion templates is alternative technique for detecting motion and computing its direction. See samples/motempl.\+py. 


\begin{DoxyItemize}
\item cv\+::motempl\+::update\+Motion\+History
\item cv\+::motempl\+::calc\+Motion\+Gradient
\item cv\+::motempl\+::calc\+Global\+Orientation
\item cv\+::motempl\+::segment\+Motion 
\end{DoxyItemize}

Functions reading and writing .flo files in \char`\"{}\+Middlebury\char`\"{} format, see\+: \href{http://vision.middlebury.edu/flow/code/flow-code/README.txt}{\tt http\+://vision.\+middlebury.\+edu/flow/code/flow-\/code/\+R\+E\+A\+D\+M\+E.\+txt} 


\begin{DoxyItemize}
\item cv\+::optflow\+::read\+Optical\+Flow
\item cv\+::optflow\+::write\+Optical\+Flow 
\end{DoxyItemize}

/$\ast$$\ast$\+This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

/$\ast$$\ast$


\begin{DoxyParams}{Parameters}
{\em silhouette} & Silhouette mask that has non-\/zero pixels where the motion occurs. \\
\hline
{\em mhi} & Motion history image that is updated by the function (single-\/channel, 32-\/bit floating-\/point). \\
\hline
{\em timestamp} & Current time in milliseconds or other units. \\
\hline
{\em duration} & Maximal duration of the motion track in the same units as timestamp . \\
\hline
\end{DoxyParams}
The function updates the motion history image as follows\+: 

\[\texttt{mhi} (x,y)= \forkthree{\texttt{timestamp}}{if \(\texttt{silhouette}(x,y) \ne 0\)}{0}{if \(\texttt{silhouette}(x,y) = 0\) and \(\texttt{mhi} < (\texttt{timestamp} - \texttt{duration})\)}{\texttt{mhi}(x,y)}{otherwise}\] 

That is, M\+HI pixels where the motion occurs are set to the current timestamp , while the pixels where the motion happened last time a long time ago are cleared. 

The function, together with calc\+Motion\+Gradient and calc\+Global\+Orientation , implements a motion templates technique described in {\bfseries [Davis97]} and {\bfseries [Bradski00]} . 

\subsection{Function Documentation}
\mbox{\Hypertarget{group__optflow_gae09be23e6ebae54e6dad95914a82282d}\label{group__optflow_gae09be23e6ebae54e6dad95914a82282d}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!calc\+Global\+Orientation@{calc\+Global\+Orientation}}
\index{calc\+Global\+Orientation@{calc\+Global\+Orientation}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{calc\+Global\+Orientation()}{calcGlobalOrientation()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Global\+Orientation (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{orientation,  }\item[{@By\+Val Mat}]{mask,  }\item[{@By\+Val Mat}]{mhi,  }\item[{double}]{timestamp,  }\item[{double}]{duration }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates a global motion orientation in a selected region. 


\begin{DoxyParams}{Parameters}
{\em orientation} & Motion gradient orientation image calculated by the function calc\+Motion\+Gradient \\
\hline
{\em mask} & Mask image. It may be a conjunction of a valid gradient mask, also calculated by calc\+Motion\+Gradient , and the mask of a region whose direction needs to be calculated. \\
\hline
{\em mhi} & Motion history image calculated by update\+Motion\+History . \\
\hline
{\em timestamp} & Timestamp passed to update\+Motion\+History . \\
\hline
{\em duration} & Maximum duration of a motion track in milliseconds, passed to update\+Motion\+History \\
\hline
\end{DoxyParams}
The function calculates an average motion direction in the selected region and returns the angle between 0 degrees and 360 degrees. The average direction is computed from the weighted orientation histogram, where a recent motion has a larger weight and the motion occurred in the past has a smaller weight, as recorded in mhi . \mbox{\Hypertarget{group__optflow_ga1df8e7b81e72fc2df163a156ec07b5ed}\label{group__optflow_ga1df8e7b81e72fc2df163a156ec07b5ed}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!calc\+Motion\+Gradient@{calc\+Motion\+Gradient}}
\index{calc\+Motion\+Gradient@{calc\+Motion\+Gradient}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{calc\+Motion\+Gradient()}{calcMotionGradient()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Motion\+Gradient (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{mhi,  }\item[{@By\+Val Mat}]{mask,  }\item[{@By\+Val Mat}]{orientation,  }\item[{double}]{delta1,  }\item[{double}]{delta2,  }\item[{int}]{aperture\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates a gradient orientation of a motion history image. 


\begin{DoxyParams}{Parameters}
{\em mhi} & Motion history single-\/channel floating-\/point image. \\
\hline
{\em mask} & Output mask image that has the type C\+V\+\_\+8\+U\+C1 and the same size as mhi . Its non-\/zero elements mark pixels where the motion gradient data is correct. \\
\hline
{\em orientation} & Output motion gradient orientation image that has the same type and the same size as mhi . Each pixel of the image is a motion orientation, from 0 to 360 degrees. \\
\hline
{\em delta1} & Minimal (or maximal) allowed difference between mhi values within a pixel neighborhood. \\
\hline
{\em delta2} & Maximal (or minimal) allowed difference between mhi values within a pixel neighborhood. That is, the function finds the minimum ( $m(x,y)$ ) and maximum ( $M(x,y)$ ) mhi values over $3 \times 3$ neighborhood of each pixel and marks the motion orientation at $(x, y)$ as valid only if \[\min ( \texttt{delta1} , \texttt{delta2} ) \le M(x,y)-m(x,y) \le \max ( \texttt{delta1} , \texttt{delta2} ).\] \\
\hline
{\em aperture\+Size} & Aperture size of the Sobel operator. \\
\hline
\end{DoxyParams}
The function calculates a gradient orientation at each pixel $(x, y)$ as\+: 

\[\texttt{orientation} (x,y)= \arctan{\frac{d\texttt{mhi}/dy}{d\texttt{mhi}/dx}}\] 

In fact, fast\+Atan2 and phase are used so that the computed angle is measured in degrees and covers the full range 0..360. Also, the mask is filled to indicate pixels where the computed angle is valid. 

\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item (Python) An example on how to perform a motion template technique can be found at opencv\+\_\+source\+\_\+code/samples/python2/motempl.\+py 
\end{DoxyItemize}
\end{DoxyNote}
\mbox{\Hypertarget{group__optflow_ga76902de70b538596bed7e39b7777384d}\label{group__optflow_ga76902de70b538596bed7e39b7777384d}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!calc\+Optical\+Flow\+SF@{calc\+Optical\+Flow\+SF}}
\index{calc\+Optical\+Flow\+SF@{calc\+Optical\+Flow\+SF}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{calc\+Optical\+Flow\+S\+F()}{calcOpticalFlowSF()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+SF (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{from,  }\item[{@By\+Val Mat}]{to,  }\item[{@By\+Val Mat}]{flow,  }\item[{int}]{layers,  }\item[{int}]{averaging\+\_\+block\+\_\+size,  }\item[{int}]{max\+\_\+flow,  }\item[{double}]{sigma\+\_\+dist,  }\item[{double}]{sigma\+\_\+color,  }\item[{int}]{postprocess\+\_\+window,  }\item[{double}]{sigma\+\_\+dist\+\_\+fix,  }\item[{double}]{sigma\+\_\+color\+\_\+fix,  }\item[{double}]{occ\+\_\+thr,  }\item[{int}]{upscale\+\_\+averaging\+\_\+radius,  }\item[{double}]{upscale\+\_\+sigma\+\_\+dist,  }\item[{double}]{upscale\+\_\+sigma\+\_\+color,  }\item[{double}]{speed\+\_\+up\+\_\+thr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculate an optical flow using \char`\"{}\+Simple\+Flow\char`\"{} algorithm. 


\begin{DoxyParams}{Parameters}
{\em from} & First 8-\/bit 3-\/channel image. \\
\hline
{\em to} & Second 8-\/bit 3-\/channel image of the same size as prev \\
\hline
{\em flow} & computed flow image that has the same size as prev and type C\+V\+\_\+32\+F\+C2 \\
\hline
{\em layers} & Number of layers \\
\hline
{\em averaging\+\_\+block\+\_\+size} & Size of block through which we sum up when calculate cost function for pixel \\
\hline
{\em max\+\_\+flow} & maximal flow that we search at each level \\
\hline
{\em sigma\+\_\+dist} & vector smooth spatial sigma parameter \\
\hline
{\em sigma\+\_\+color} & vector smooth color sigma parameter \\
\hline
{\em postprocess\+\_\+window} & window size for postprocess cross bilateral filter \\
\hline
{\em sigma\+\_\+dist\+\_\+fix} & spatial sigma for postprocess cross bilateralf filter \\
\hline
{\em sigma\+\_\+color\+\_\+fix} & color sigma for postprocess cross bilateral filter \\
\hline
{\em occ\+\_\+thr} & threshold for detecting occlusions \\
\hline
{\em upscale\+\_\+averaging\+\_\+radius} & window size for bilateral upscale operation \\
\hline
{\em upscale\+\_\+sigma\+\_\+dist} & spatial sigma for bilateral upscale operation \\
\hline
{\em upscale\+\_\+sigma\+\_\+color} & color sigma for bilateral upscale operation \\
\hline
{\em speed\+\_\+up\+\_\+thr} & threshold to detect point with irregular flow -\/ where flow should be recalculated after upscale \\
\hline
\end{DoxyParams}
See {\bfseries [Tao2012]} . And site of project -\/ \href{http://graphics.berkeley.edu/papers/Tao-SAN-2012-05/}{\tt http\+://graphics.\+berkeley.\+edu/papers/\+Tao-\/\+S\+A\+N-\/2012-\/05/}. 

\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item An example using the simple\+Flow algorithm can be found at samples/simpleflow\+\_\+demo.\+cpp 
\end{DoxyItemize}
\end{DoxyNote}
\mbox{\Hypertarget{group__optflow_gab202f6c782e9356cf2a96620732785a9}\label{group__optflow_gab202f6c782e9356cf2a96620732785a9}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!calc\+Optical\+Flow\+Sparse\+To\+Dense@{calc\+Optical\+Flow\+Sparse\+To\+Dense}}
\index{calc\+Optical\+Flow\+Sparse\+To\+Dense@{calc\+Optical\+Flow\+Sparse\+To\+Dense}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{calc\+Optical\+Flow\+Sparse\+To\+Dense()}{calcOpticalFlowSparseToDense()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+calc\+Optical\+Flow\+Sparse\+To\+Dense (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{from,  }\item[{@By\+Val Mat}]{to,  }\item[{@By\+Val Mat}]{flow,  }\item[{int}]{grid\+\_\+step,  }\item[{int}]{k,  }\item[{float}]{sigma,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{use\+\_\+post\+\_\+proc,  }\item[{float}]{fgs\+\_\+lambda,  }\item[{float}]{fgs\+\_\+sigma }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Fast dense optical flow based on Pyr\+LK sparse matches interpolation. 


\begin{DoxyParams}{Parameters}
{\em from} & first 8-\/bit 3-\/channel or 1-\/channel image. \\
\hline
{\em to} & second 8-\/bit 3-\/channel or 1-\/channel image of the same size as from \\
\hline
{\em flow} & computed flow image that has the same size as from and C\+V\+\_\+32\+F\+C2 type \\
\hline
{\em grid\+\_\+step} & stride used in sparse match computation. Lower values usually result in higher quality but slow down the algorithm. \\
\hline
{\em k} & number of nearest-\/neighbor matches considered, when fitting a locally affine model. Lower values can make the algorithm noticeably faster at the cost of some quality degradation. \\
\hline
{\em sigma} & parameter defining how fast the weights decrease in the locally-\/weighted affine fitting. Higher values can help preserve fine details, lower values can help to get rid of the noise in the output flow. \\
\hline
{\em use\+\_\+post\+\_\+proc} & defines whether the ximgproc\+::fast\+Global\+Smoother\+Filter() is used for post-\/processing after interpolation \\
\hline
{\em fgs\+\_\+lambda} & see the respective parameter of the ximgproc\+::fast\+Global\+Smoother\+Filter() \\
\hline
{\em fgs\+\_\+sigma} & see the respective parameter of the ximgproc\+::fast\+Global\+Smoother\+Filter() \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__optflow_ga27f2a261b7f69f4eaaf2aa2552943a1a}\label{group__optflow_ga27f2a261b7f69f4eaaf2aa2552943a1a}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!create\+Opt\+Flow\+\_\+\+Deep\+Flow@{create\+Opt\+Flow\+\_\+\+Deep\+Flow}}
\index{create\+Opt\+Flow\+\_\+\+Deep\+Flow@{create\+Opt\+Flow\+\_\+\+Deep\+Flow}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{create\+Opt\+Flow\+\_\+\+Deep\+Flow()}{createOptFlow\_DeepFlow()}}
{\footnotesize\ttfamily static native Dense\+Optical\+Flow org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Deep\+Flow (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Deep\+Flow optical flow algorithm implementation. 

The class implements the Deep\+Flow optical flow algorithm described in {\bfseries [Weinzaepfel2013]} . See also \href{http://lear.inrialpes.fr/src/deepmatching/}{\tt http\+://lear.\+inrialpes.\+fr/src/deepmatching/} . Parameters -\/ class fields -\/ that may be modified after creating a class instance\+:
\begin{DoxyItemize}
\item member float alpha Smoothness assumption weight
\item member float delta Color constancy assumption weight
\item member float gamma Gradient constancy weight
\item member float sigma Gaussian smoothing parameter
\item member int min\+Size Minimal dimension of an image in the pyramid (next, smaller images in the pyramid are generated until one of the dimensions reaches this size)
\item member float downscale\+Factor Scaling factor in the image pyramid (must be $<$ 1)
\item member int fixed\+Point\+Iterations How many iterations on each level of the pyramid
\item member int sor\+Iterations Iterations of Succesive Over-\/\+Relaxation (solver)
\item member float omega Relaxation factor in S\+OR 
\end{DoxyItemize}\mbox{\Hypertarget{group__optflow_gac107283f5dba4f320df3d9894aad537b}\label{group__optflow_gac107283f5dba4f320df3d9894aad537b}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!create\+Opt\+Flow\+\_\+\+D\+IS@{create\+Opt\+Flow\+\_\+\+D\+IS}}
\index{create\+Opt\+Flow\+\_\+\+D\+IS@{create\+Opt\+Flow\+\_\+\+D\+IS}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{create\+Opt\+Flow\+\_\+\+D\+I\+S()}{createOptFlow\_DIS()}}
{\footnotesize\ttfamily static native D\+I\+S\+Optical\+Flow org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+D\+IS (\begin{DoxyParamCaption}\item[{int}]{preset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Creates an instance of D\+I\+S\+Optical\+Flow. 


\begin{DoxyParams}{Parameters}
{\em preset} & one of P\+R\+E\+S\+E\+T\+\_\+\+U\+L\+T\+R\+A\+F\+A\+ST, P\+R\+E\+S\+E\+T\+\_\+\+F\+A\+ST and P\+R\+E\+S\+E\+T\+\_\+\+M\+E\+D\+I\+UM \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__optflow_gabd230cc626a64515ec35ac6c6c7fc099}\label{group__optflow_gabd230cc626a64515ec35ac6c6c7fc099}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!create\+Opt\+Flow\+\_\+\+Farneback@{create\+Opt\+Flow\+\_\+\+Farneback}}
\index{create\+Opt\+Flow\+\_\+\+Farneback@{create\+Opt\+Flow\+\_\+\+Farneback}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{create\+Opt\+Flow\+\_\+\+Farneback()}{createOptFlow\_Farneback()}}
{\footnotesize\ttfamily static native Dense\+Optical\+Flow org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Farneback (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Additional interface to the Farneback\textquotesingle{}s algorithm -\/ calc\+Optical\+Flow\+Farneback() \mbox{\Hypertarget{group__optflow_gace52b781a9780c4c9a20951a2bec314d}\label{group__optflow_gace52b781a9780c4c9a20951a2bec314d}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!create\+Opt\+Flow\+\_\+\+Simple\+Flow@{create\+Opt\+Flow\+\_\+\+Simple\+Flow}}
\index{create\+Opt\+Flow\+\_\+\+Simple\+Flow@{create\+Opt\+Flow\+\_\+\+Simple\+Flow}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{create\+Opt\+Flow\+\_\+\+Simple\+Flow()}{createOptFlow\_SimpleFlow()}}
{\footnotesize\ttfamily static native Dense\+Optical\+Flow org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Simple\+Flow (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Additional interface to the Simple\+Flow algorithm -\/ calc\+Optical\+Flow\+S\+F() \mbox{\Hypertarget{group__optflow_ga2033e98010d9ac8b150503a107601946}\label{group__optflow_ga2033e98010d9ac8b150503a107601946}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense@{create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense}}
\index{create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense@{create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense()}{createOptFlow\_SparseToDense()}}
{\footnotesize\ttfamily static native Dense\+Optical\+Flow org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+create\+Opt\+Flow\+\_\+\+Sparse\+To\+Dense (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Additional interface to the Sparse\+To\+Dense\+Flow algorithm -\/ \hyperlink{group__optflow_gab202f6c782e9356cf2a96620732785a9}{calc\+Optical\+Flow\+Sparse\+To\+Dense()} \mbox{\Hypertarget{group__optflow_ga8adc9b054c1518ab41c20d8ada51b9b7}\label{group__optflow_ga8adc9b054c1518ab41c20d8ada51b9b7}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!read\+Optical\+Flow@{read\+Optical\+Flow}}
\index{read\+Optical\+Flow@{read\+Optical\+Flow}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{read\+Optical\+Flow()}{readOpticalFlow()}}
{\footnotesize\ttfamily static native Mat org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+read\+Optical\+Flow (\begin{DoxyParamCaption}\item[{@Str Byte\+Pointer}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Read a .flo file. 


\begin{DoxyParams}{Parameters}
{\em path} & Path to the file to be loaded \\
\hline
\end{DoxyParams}
The function read\+Optical\+Flow loads a flow field from a file and returns it as a single matrix. Resulting Mat has a type C\+V\+\_\+32\+F\+C2 -\/ floating-\/point, 2-\/channel. First channel corresponds to the flow in the horizontal direction (u), second -\/ vertical (v). \mbox{\Hypertarget{group__optflow_gad1ff5ca68f3f39b0547c8d249b99185b}\label{group__optflow_gad1ff5ca68f3f39b0547c8d249b99185b}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!segment\+Motion@{segment\+Motion}}
\index{segment\+Motion@{segment\+Motion}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{segment\+Motion()}{segmentMotion()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+segment\+Motion (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{mhi,  }\item[{@By\+Val Mat}]{segmask,  }\item[{@By\+Ref Rect\+Vector}]{bounding\+Rects,  }\item[{double}]{timestamp,  }\item[{double}]{seg\+Thresh }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Splits a motion history image into a few parts corresponding to separate independent motions (for example, left hand, right hand). 


\begin{DoxyParams}{Parameters}
{\em mhi} & Motion history image. \\
\hline
{\em segmask} & Image where the found mask should be stored, single-\/channel, 32-\/bit floating-\/point. \\
\hline
{\em bounding\+Rects} & Vector containing R\+O\+Is of motion connected components. \\
\hline
{\em timestamp} & Current time in milliseconds or other units. \\
\hline
{\em seg\+Thresh} & Segmentation threshold that is recommended to be equal to the interval between motion history \char`\"{}steps\char`\"{} or greater. \\
\hline
\end{DoxyParams}
The function finds all of the motion segments and marks them in segmask with individual values (1,2,...). It also computes a vector with R\+O\+Is of motion connected components. After that the motion direction for every component can be calculated with calc\+Global\+Orientation using the extracted mask of the particular component. \mbox{\Hypertarget{group__optflow_ga41bea8c25211f346782adfb40129e96e}\label{group__optflow_ga41bea8c25211f346782adfb40129e96e}} 
\index{Optical Flow Algorithms@{Optical Flow Algorithms}!write\+Optical\+Flow@{write\+Optical\+Flow}}
\index{write\+Optical\+Flow@{write\+Optical\+Flow}!Optical Flow Algorithms@{Optical Flow Algorithms}}
\subsubsection{\texorpdfstring{write\+Optical\+Flow()}{writeOpticalFlow()}}
{\footnotesize\ttfamily static native boolean org.\+bytedeco.\+javacpp.\+opencv\+\_\+optflow.\+write\+Optical\+Flow (\begin{DoxyParamCaption}\item[{@Str Byte\+Pointer}]{path,  }\item[{@By\+Val Mat}]{flow }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Write a .flo to disk. 


\begin{DoxyParams}{Parameters}
{\em path} & Path to the file to be written \\
\hline
{\em flow} & Flow field to be stored \\
\hline
\end{DoxyParams}
The function stores a flow field in a file, returns true on success, false otherwise. The flow field must be a 2-\/channel, floating-\/point matrix (C\+V\+\_\+32\+F\+C2). First channel corresponds to the flow in the horizontal direction (u), second -\/ vertical (v). 