\hypertarget{group__imgproc__hist}{}\section{Histograms}
\label{group__imgproc__hist}\index{Histograms@{Histograms}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static native void \hyperlink{group__imgproc__hist_ga5d3d264cae4eeaf1ffac100661154b5a}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\begin{DoxyCompactList}\small\item\em Calculates a histogram of a set of arrays. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__hist_gaceb265aae7d380ace4e1a9a25a4932dd}\label{group__imgproc__hist_gaceb265aae7d380ace4e1a9a25a4932dd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gadcdbf439ce211663d2d46970bc60b86a}\label{group__imgproc__hist_gadcdbf439ce211663d2d46970bc60b86a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga7f5f92e2727bbc0918a60e613dd95c49}\label{group__imgproc__hist_ga7f5f92e2727bbc0918a60e613dd95c49}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, int dims, @Const Int\+Buffer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga71866520c7d34c56746cc6bc54746174}\label{group__imgproc__hist_ga71866520c7d34c56746cc6bc54746174}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, int dims, @Const Int\+Buffer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga5bf3bd861e2d2ab7fd50820d495033b6}\label{group__imgproc__hist_ga5bf3bd861e2d2ab7fd50820d495033b6}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, int dims, @Const int\mbox{[}$\,$\mbox{]} hist\+Size, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gad79b2c6f2691a2d03939c2597f03ccb5}\label{group__imgproc__hist_gad79b2c6f2691a2d03939c2597f03ccb5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, int dims, @Const int\mbox{[}$\,$\mbox{]} hist\+Size, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga418cb6f62e8282aa89b4c4ccaea15a5e}\label{group__imgproc__hist_ga418cb6f62e8282aa89b4c4ccaea15a5e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gab7b8b4293328b8afb7127d23a211ace5}\label{group__imgproc__hist_gab7b8b4293328b8afb7127d23a211ace5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
static native void \hyperlink{group__imgproc__hist_ga09dcede19ebb0d3cc41d719fa761849c}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga76b084059c516f089f2359b4f2436645}\label{group__imgproc__hist_ga76b084059c516f089f2359b4f2436645}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gacc032f713b5a473e1adfb48c5e746ebc}\label{group__imgproc__hist_gacc032f713b5a473e1adfb48c5e746ebc}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga8186573f693750cebb0e7035b0eb6490}\label{group__imgproc__hist_ga8186573f693750cebb0e7035b0eb6490}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Buffer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga962425fe024650629c01d7d5fe678c41}\label{group__imgproc__hist_ga962425fe024650629c01d7d5fe678c41}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Buffer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga8401b27456acdde4fff26e7213ffe7ff}\label{group__imgproc__hist_ga8401b27456acdde4fff26e7213ffe7ff}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const int\mbox{[}$\,$\mbox{]} hist\+Size, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga233d27f68b7a9ce9a73a24a24b997aef}\label{group__imgproc__hist_ga233d27f68b7a9ce9a73a24a24b997aef}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const int\mbox{[}$\,$\mbox{]} hist\+Size, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga57131482263a931d635871aedff63621}\label{group__imgproc__hist_ga57131482263a931d635871aedff63621}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean uniform, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga916e74a4d18cf3f357e3a11ea1bbd1a0}\label{group__imgproc__hist_ga916e74a4d18cf3f357e3a11ea1bbd1a0}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Ref Sparse\+Mat hist, int dims, @Const Int\+Pointer hist\+Size, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
static native void \hyperlink{group__imgproc__hist_gaae5adf8a34c06197b68e79d8dcb9c9fd}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga2cc7bdd96b3fc36b32d6143df5ea392e}\label{group__imgproc__hist_ga2cc7bdd96b3fc36b32d6143df5ea392e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga30c308d7acd673227e77e24906d247a2}\label{group__imgproc__hist_ga30c308d7acd673227e77e24906d247a2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga58e4192f36103e5179852a23a7987409}\label{group__imgproc__hist_ga58e4192f36103e5179852a23a7987409}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga219419019fcf7a802cbad2fa504a6de5}\label{group__imgproc__hist_ga219419019fcf7a802cbad2fa504a6de5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga2bd46723f7d11c8a327e1e51d244014d}\label{group__imgproc__hist_ga2bd46723f7d11c8a327e1e51d244014d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga426a6950b99d749c28cc0961ef6b8828}\label{group__imgproc__hist_ga426a6950b99d749c28cc0961ef6b8828}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga71e9fc1f57aba73cfeffa1b9252f7991}\label{group__imgproc__hist_ga71e9fc1f57aba73cfeffa1b9252f7991}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga8b239626280ed867adb3866003af2b8e}\label{group__imgproc__hist_ga8b239626280ed867adb3866003af2b8e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga5145eca9f49c32b0ef49e1962d3baded}\label{group__imgproc__hist_ga5145eca9f49c32b0ef49e1962d3baded}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga4b1312c7bd2bab7e123d64871c51a976}\label{group__imgproc__hist_ga4b1312c7bd2bab7e123d64871c51a976}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gaee48c08d8765147974dadfa0065ea472}\label{group__imgproc__hist_gaee48c08d8765147974dadfa0065ea472}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga46f6a1802466c6bf6695ce2ae67a6d7a}\label{group__imgproc__hist_ga46f6a1802466c6bf6695ce2ae67a6d7a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga09b19271ab093192e12bde6d6ecdb9d6}\label{group__imgproc__hist_ga09b19271ab093192e12bde6d6ecdb9d6}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga99e03af5e4f4124da1f330d7e1a4b1ad}\label{group__imgproc__hist_ga99e03af5e4f4124da1f330d7e1a4b1ad}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga1ff60a43309a955a7a64082289d6116a}\label{group__imgproc__hist_ga1ff60a43309a955a7a64082289d6116a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gab99d8476b8aa00ecef6621e0926e2145}\label{group__imgproc__hist_gab99d8476b8aa00ecef6621e0926e2145}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gae6a213f0decf4b3e375a0c06e56f546d}\label{group__imgproc__hist_gae6a213f0decf4b3e375a0c06e56f546d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gad28f0f3e832ea1914cead23468929e9c}\label{group__imgproc__hist_gad28f0f3e832ea1914cead23468929e9c}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga715b1487141969b5984ef236e39bf4a1}\label{group__imgproc__hist_ga715b1487141969b5984ef236e39bf4a1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat mask, @By\+Val Mat hist, @Std\+Vector Int\+Pointer hist\+Size, @Std\+Vector Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga4653ced3c298d8131ffaab69f027fe6a}\label{group__imgproc__hist_ga4653ced3c298d8131ffaab69f027fe6a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gad155fc5f3f2238168b1d13978e79f69a}\label{group__imgproc__hist_gad155fc5f3f2238168b1d13978e79f69a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector Int\+Buffer hist\+Size, @Std\+Vector Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga5f25e576c6034ea47935a2609ad90ccc}\label{group__imgproc__hist_ga5f25e576c6034ea47935a2609ad90ccc}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, @Cast(\char`\"{}bool\char`\"{}) boolean accumulate)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gad2ffb7df0f088c57acd50282521c7459}\label{group__imgproc__hist_gad2ffb7df0f088c57acd50282521c7459}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat mask, @By\+Val U\+Mat hist, @Std\+Vector int\mbox{[}$\,$\mbox{]} hist\+Size, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges)
\item 
static native void \hyperlink{group__imgproc__hist_gaf0312cafdf92e7baeb662d460281307e}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat hist, @By\+Val Mat back\+Project, @Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\begin{DoxyCompactList}\small\item\em Calculates the back projection of a histogram. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__hist_gac92a2ab6b4738fd23a9b0cc7f42684ba}\label{group__imgproc__hist_gac92a2ab6b4738fd23a9b0cc7f42684ba}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gabdda69d5a6387c13016f74dc6fe231cd}\label{group__imgproc__hist_gabdda69d5a6387c13016f74dc6fe231cd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gaea96bfc08cb0cc264d4ec1709f87fe7a}\label{group__imgproc__hist_gaea96bfc08cb0cc264d4ec1709f87fe7a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Buffer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga462aa4e6f5b8d5c754e3f8be7123557a}\label{group__imgproc__hist_ga462aa4e6f5b8d5c754e3f8be7123557a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @By\+Val Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga5237f90551355b4937c17c95a75b100f}\label{group__imgproc__hist_ga5237f90551355b4937c17c95a75b100f}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga7eaeb0cb8cbaebd49ef5f2d0648658fa}\label{group__imgproc__hist_ga7eaeb0cb8cbaebd49ef5f2d0648658fa}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gae5d1c91c75e0963ac92f8b85336228dd}\label{group__imgproc__hist_gae5d1c91c75e0963ac92f8b85336228dd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga31dae41ed9c37e469afb44851f862d9b}\label{group__imgproc__hist_ga31dae41ed9c37e469afb44851f862d9b}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
static native void \hyperlink{group__imgproc__hist_ga7b4e3550a98e1190b81817959e277fe0}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val Mat back\+Project, @Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gac4f5a5bfb26b835a39df88eac0c0ac52}\label{group__imgproc__hist_gac4f5a5bfb26b835a39df88eac0c0ac52}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gacbb1d983ac8bfe7d9c9b12e05c6aa5e8}\label{group__imgproc__hist_gacbb1d983ac8bfe7d9c9b12e05c6aa5e8}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gacfd86500d632bf420e5e9bb4f0452422}\label{group__imgproc__hist_gacfd86500d632bf420e5e9bb4f0452422}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Buffer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga5ffa0309f32cff5e6c35525a7ee67725}\label{group__imgproc__hist_ga5ffa0309f32cff5e6c35525a7ee67725}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Buffer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Buffer ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga926103594e5e9094f5d61c1ead0b50c4}\label{group__imgproc__hist_ga926103594e5e9094f5d61c1ead0b50c4}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gafc59a25db96c4d1665b2a18938b033c3}\label{group__imgproc__hist_gafc59a25db96c4d1665b2a18938b033c3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const int\mbox{[}$\,$\mbox{]} channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr float\mbox{[}$\,$\mbox{]} ranges)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga466a1eb085e7de6a3fa44da45bb94b81}\label{group__imgproc__hist_ga466a1eb085e7de6a3fa44da45bb94b81}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges, double scale, @Cast(\char`\"{}bool\char`\"{}) boolean uniform)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga2f84a535e604b6da885d5701892d6aa3}\label{group__imgproc__hist_ga2f84a535e604b6da885d5701892d6aa3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @Const Mat images, int nimages, @Const Int\+Pointer channels, @Const @By\+Ref Sparse\+Mat hist, @By\+Val U\+Mat back\+Project, @Const @By\+Ptr\+Ptr Float\+Pointer ranges)
\item 
static native void \hyperlink{group__imgproc__hist_ga08b1470561cb4171cc528b2bdba50764}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector Float\+Pointer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gad2b95344d44522fbf00d6f9abc933d8d}\label{group__imgproc__hist_gad2b95344d44522fbf00d6f9abc933d8d}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector Float\+Buffer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga94d3f79ad555fa1efe2f2eee33c37147}\label{group__imgproc__hist_ga94d3f79ad555fa1efe2f2eee33c37147}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gaca8cc1c91710dcbd933e5a39993769a9}\label{group__imgproc__hist_gaca8cc1c91710dcbd933e5a39993769a9}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector Float\+Pointer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga95d97991465a814174f2e033354bc6c1}\label{group__imgproc__hist_ga95d97991465a814174f2e033354bc6c1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector Float\+Buffer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga582ada5adffcf69f53a5bd54f13ffff7}\label{group__imgproc__hist_ga582ada5adffcf69f53a5bd54f13ffff7}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga79c0d3878259f77173fd877022412b76}\label{group__imgproc__hist_ga79c0d3878259f77173fd877022412b76}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector Float\+Pointer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga8b8738b645ea5b4924cee98bed5f2b27}\label{group__imgproc__hist_ga8b8738b645ea5b4924cee98bed5f2b27}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector Float\+Buffer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gadcd2c2ad51cb292f1f5ad06f66c8ad8f}\label{group__imgproc__hist_gadcd2c2ad51cb292f1f5ad06f66c8ad8f}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga96aac127318e1d1e1b25a00b8fa6c975}\label{group__imgproc__hist_ga96aac127318e1d1e1b25a00b8fa6c975}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector Int\+Pointer channels, @By\+Val Mat hist, @By\+Val Mat dst, @Std\+Vector Float\+Pointer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga2b4952d579f64a3387ffbb780f5ada5e}\label{group__imgproc__hist_ga2b4952d579f64a3387ffbb780f5ada5e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val Mat\+Vector images, @Std\+Vector Int\+Buffer channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector Float\+Buffer ranges, double scale)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga91aa6cfe98f7c530b7d6fc15b516beae}\label{group__imgproc__hist_ga91aa6cfe98f7c530b7d6fc15b516beae}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project} ( @By\+Val U\+Mat\+Vector images, @Std\+Vector int\mbox{[}$\,$\mbox{]} channels, @By\+Val U\+Mat hist, @By\+Val U\+Mat dst, @Std\+Vector float\mbox{[}$\,$\mbox{]} ranges, double scale)
\item 
static native double \hyperlink{group__imgproc__hist_ga2c5a33af2393e75272a7346241822627}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+compare\+Hist} ( @By\+Val Mat H1, @By\+Val Mat H2, int method)
\begin{DoxyCompactList}\small\item\em Compares two histograms. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__hist_ga17c131d1733126972fe3ac37bc2d1155}\label{group__imgproc__hist_ga17c131d1733126972fe3ac37bc2d1155}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+compare\+Hist} ( @By\+Val U\+Mat H1, @By\+Val U\+Mat H2, int method)
\item 
static native double \hyperlink{group__imgproc__hist_gadc2285df53903ac40eb1f3ac72136eb1}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+compare\+Hist} ( @Const @By\+Ref Sparse\+Mat H1, @Const @By\+Ref Sparse\+Mat H2, int method)
\item 
static native void \hyperlink{group__imgproc__hist_gabfd0825b3947af498b1eecc64de2787c}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+equalize\+Hist} ( @By\+Val Mat src, @By\+Val Mat dst)
\begin{DoxyCompactList}\small\item\em Equalizes the histogram of a grayscale image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__hist_ga33308dee90a59116a78ea9c778cf76a2}\label{group__imgproc__hist_ga33308dee90a59116a78ea9c778cf76a2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+equalize\+Hist} ( @By\+Val U\+Mat src, @By\+Val U\+Mat dst)
\item 
static native float \hyperlink{group__imgproc__hist_ga754ea5294cd28cb142b11116e1c4d658}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val Mat signature1, @By\+Val Mat signature2, int dist\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) Mat cost, Float\+Pointer lower\+Bound, @By\+Val(null\+Value=\char`\"{}cv\+::\+Output\+Array(cv\+::no\+Array())\char`\"{}) Mat flow)
\begin{DoxyCompactList}\small\item\em Computes the \char`\"{}minimal work\char`\"{} distance between two weighted point configurations. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__hist_ga52794b83ef22b22d4c109e0c7b21696e}\label{group__imgproc__hist_ga52794b83ef22b22d4c109e0c7b21696e}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val Mat signature1, @By\+Val Mat signature2, int dist\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga45bd7b991f2c35d8ad5a6fef5154a66b}\label{group__imgproc__hist_ga45bd7b991f2c35d8ad5a6fef5154a66b}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val Mat signature1, @By\+Val Mat signature2, int dist\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) Mat cost, Float\+Buffer lower\+Bound, @By\+Val(null\+Value=\char`\"{}cv\+::\+Output\+Array(cv\+::no\+Array())\char`\"{}) Mat flow)
\item 
\mbox{\Hypertarget{group__imgproc__hist_gaf4910259b923af1e2be2a597e74fffab}\label{group__imgproc__hist_gaf4910259b923af1e2be2a597e74fffab}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val U\+Mat signature1, @By\+Val U\+Mat signature2, int dist\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) U\+Mat cost, float\mbox{[}$\,$\mbox{]} lower\+Bound, @By\+Val(null\+Value=\char`\"{}cv\+::\+Output\+Array(cv\+::no\+Array())\char`\"{}) U\+Mat flow)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga0961fc0ee38183bd21ac336a90602949}\label{group__imgproc__hist_ga0961fc0ee38183bd21ac336a90602949}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val U\+Mat signature1, @By\+Val U\+Mat signature2, int dist\+Type)
\item 
\mbox{\Hypertarget{group__imgproc__hist_ga46a74595f01418c6ab4d7271744b162c}\label{group__imgproc__hist_ga46a74595f01418c6ab4d7271744b162c}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD} ( @By\+Val U\+Mat signature1, @By\+Val U\+Mat signature2, int dist\+Type, @By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) U\+Mat cost, Float\+Pointer lower\+Bound, @By\+Val(null\+Value=\char`\"{}cv\+::\+Output\+Array(cv\+::no\+Array())\char`\"{}) U\+Mat flow)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static final int \hyperlink{group__imgproc__hist_ga191607eeab47aa090f1b49b4e1198f6a}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
imgproc\+\_\+transform 

/$\ast$$\ast$ 

\subsection{Function Documentation}
\mbox{\Hypertarget{group__imgproc__hist_gaf0312cafdf92e7baeb662d460281307e}\label{group__imgproc__hist_gaf0312cafdf92e7baeb662d460281307e}} 
\index{Histograms@{Histograms}!calc\+Back\+Project@{calc\+Back\+Project}}
\index{calc\+Back\+Project@{calc\+Back\+Project}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Back\+Project()}{calcBackProject()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project (\begin{DoxyParamCaption}\item[{@Const Mat}]{images,  }\item[{int}]{nimages,  }\item[{@Const Int\+Pointer}]{channels,  }\item[{@By\+Val Mat}]{hist,  }\item[{@By\+Val Mat}]{back\+Project,  }\item[{@Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer}]{ranges,  }\item[{double}]{scale,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{uniform }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the back projection of a histogram. 

The function cv\+::calc\+Back\+Project calculates the back project of the histogram. That is, similarly to cv\+::calc\+Hist , at each location (x, y) the function collects the values from the selected channels in the input images and finds the corresponding histogram bin. But instead of incrementing it, the function reads the bin value, scales it by scale , and stores in back\+Project(x,y) . In terms of statistics, the function computes probability of each element value in respect with the empirical probability distribution represented by the histogram. See how, for example, you can find and track a bright-\/colored object in a scene\+: 


\begin{DoxyItemize}
\item Before tracking, show the object to the camera so that it covers almost the whole frame. Calculate a hue histogram. The histogram may have strong maximums, corresponding to the dominant colors in the object. 
\end{DoxyItemize}


\begin{DoxyItemize}
\item When tracking, calculate a back projection of a hue plane of each input video frame using that pre-\/computed histogram. Threshold the back projection to suppress weak colors. It may also make sense to suppress pixels with non-\/sufficient color saturation and too dark or too bright pixels. 
\end{DoxyItemize}


\begin{DoxyItemize}
\item Find connected components in the resulting picture and choose, for example, the largest component. 
\end{DoxyItemize}

This is an approximate algorithm of the Cam\+Shift color object tracker. 


\begin{DoxyParams}{Parameters}
{\em images} & Source arrays. They all should have the same depth, C\+V\+\_\+8U, C\+V\+\_\+16U or C\+V\+\_\+32F , and the same size. Each of them can have an arbitrary number of channels. \\
\hline
{\em nimages} & Number of source images. \\
\hline
{\em channels} & The list of channels used to compute the back projection. The number of channels must match the histogram dimensionality. The first array channels are numerated from 0 to images\mbox{[}0\mbox{]}.channels()-\/1 , the second array channels are counted from images\mbox{[}0\mbox{]}.channels() to images\mbox{[}0\mbox{]}.channels() + images\mbox{[}1\mbox{]}.channels()-\/1, and so on. \\
\hline
{\em hist} & Input histogram that can be dense or sparse. \\
\hline
{\em back\+Project} & Destination back projection array that is a single-\/channel array of the same size and depth as images\mbox{[}0\mbox{]} . \\
\hline
{\em ranges} & Array of arrays of the histogram bin boundaries in each dimension. See cv\+::calc\+Hist . \\
\hline
{\em scale} & Optional scale factor for the output back projection. \\
\hline
{\em uniform} & Flag indicating whether the histogram is uniform or not (see above). \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
cv\+::calc\+Hist, cv\+::compare\+Hist 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__hist_ga7b4e3550a98e1190b81817959e277fe0}\label{group__imgproc__hist_ga7b4e3550a98e1190b81817959e277fe0}} 
\index{Histograms@{Histograms}!calc\+Back\+Project@{calc\+Back\+Project}}
\index{calc\+Back\+Project@{calc\+Back\+Project}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Back\+Project()}{calcBackProject()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project (\begin{DoxyParamCaption}\item[{@Const Mat}]{images,  }\item[{int}]{nimages,  }\item[{@Const Int\+Pointer}]{channels,  }\item[{@Const @By\+Ref Sparse\+Mat}]{hist,  }\item[{@By\+Val Mat}]{back\+Project,  }\item[{@Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer}]{ranges,  }\item[{double}]{scale,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{uniform }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__hist_ga08b1470561cb4171cc528b2bdba50764}\label{group__imgproc__hist_ga08b1470561cb4171cc528b2bdba50764}} 
\index{Histograms@{Histograms}!calc\+Back\+Project@{calc\+Back\+Project}}
\index{calc\+Back\+Project@{calc\+Back\+Project}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Back\+Project()}{calcBackProject()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Back\+Project (\begin{DoxyParamCaption}\item[{@By\+Val Mat\+Vector}]{images,  }\item[{@Std\+Vector Int\+Pointer}]{channels,  }\item[{@By\+Val Mat}]{hist,  }\item[{@By\+Val Mat}]{dst,  }\item[{@Std\+Vector Float\+Pointer}]{ranges,  }\item[{double}]{scale }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__hist_ga5d3d264cae4eeaf1ffac100661154b5a}\label{group__imgproc__hist_ga5d3d264cae4eeaf1ffac100661154b5a}} 
\index{Histograms@{Histograms}!calc\+Hist@{calc\+Hist}}
\index{calc\+Hist@{calc\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Hist()}{calcHist()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist (\begin{DoxyParamCaption}\item[{@Const Mat}]{images,  }\item[{int}]{nimages,  }\item[{@Const Int\+Pointer}]{channels,  }\item[{@By\+Val Mat}]{mask,  }\item[{@By\+Val Mat}]{hist,  }\item[{int}]{dims,  }\item[{@Const Int\+Pointer}]{hist\+Size,  }\item[{@Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer}]{ranges,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{uniform,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{accumulate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates a histogram of a set of arrays. 

The function cv\+::calc\+Hist calculates the histogram of one or more arrays. The elements of a tuple used to increment a histogram bin are taken from the corresponding input arrays at the same location. The sample below shows how to compute a 2D Hue-\/\+Saturation histogram for a color image. \+: 
\begin{DoxyPre}
\begin{DoxyCode}
\textcolor{preprocessor}{#include <opencv2/imgproc.hpp>}
\textcolor{preprocessor}{#include <opencv2/highgui.hpp>}

\textcolor{keyword}{using namespace }cv;

\textcolor{keywordtype}{int} main( \textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv )
\{
    Mat src, hsv;
    \textcolor{keywordflow}{if}( argc != 2 || !(src=imread(argv[1], 1)).data )
        \textcolor{keywordflow}{return} -1;

    \hyperlink{group__imgproc__misc_gaab99985581c43cce9df680e6586cb9ef}{cvtColor}(src, hsv, COLOR\_BGR2HSV);

    \textcolor{comment}{// Quantize the hue to 30 levels}
    \textcolor{comment}{// and the saturation to 32 levels}
    \textcolor{keywordtype}{int} hbins = 30, sbins = 32;
    \textcolor{keywordtype}{int} histSize[] = \{hbins, sbins\};
    \textcolor{comment}{// hue varies from 0 to 179, see cvtColor}
    \textcolor{keywordtype}{float} hranges[] = \{ 0, 180 \};
    \textcolor{comment}{// saturation varies from 0 (black-gray-white) to}
    \textcolor{comment}{// 255 (pure spectrum color)}
    \textcolor{keywordtype}{float} sranges[] = \{ 0, 256 \};
    \textcolor{keyword}{const} \textcolor{keywordtype}{float}* ranges[] = \{ hranges, sranges \};
    MatND hist;
    \textcolor{comment}{// we compute the histogram from the 0-th and 1-st channels}
    \textcolor{keywordtype}{int} channels[] = \{0, 1\};

    \hyperlink{group__imgproc__hist_ga5d3d264cae4eeaf1ffac100661154b5a}{calcHist}( &hsv, 1, channels, Mat(), \textcolor{comment}{// do not use mask}
             hist, 2, histSize, ranges,
             \textcolor{keyword}{true}, \textcolor{comment}{// the histogram is uniform}
             \textcolor{keyword}{false} );
    \textcolor{keywordtype}{double} maxVal=0;
    minMaxLoc(hist, 0, &maxVal, 0, 0);

    \textcolor{keywordtype}{int} scale = 10;
    Mat histImg = Mat::zeros(sbins*scale, hbins*10, CV\_8UC3);

    \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} h = 0; h < hbins; h++ )
        \textcolor{keywordflow}{for}( \textcolor{keywordtype}{int} s = 0; s < sbins; s++ )
        \{
            \textcolor{keywordtype}{float} binVal = hist.at<\textcolor{keywordtype}{float}>(h, s);
            \textcolor{keywordtype}{int} intensity = cvRound(binVal*255/maxVal);
            \hyperlink{group__imgproc__draw_ga011e780e69d07eab5e5e6ac46d4d8dde}{rectangle}( histImg, fr.antproject.utils.Point(h*scale, s*scale),
                        fr.antproject.utils.Point( (h+1)*scale - 1, (s+1)*scale - 1),
                        Scalar::all(intensity),
                        CV\_FILLED );
        \}

    namedWindow( \textcolor{stringliteral}{"Source"}, 1 );
    imshow( \textcolor{stringliteral}{"Source"}, src );

    namedWindow( \textcolor{stringliteral}{"H-S Histogram"}, 1 );
    imshow( \textcolor{stringliteral}{"H-S Histogram"}, histImg );
    waitKey();
\}
\end{DoxyCode}
 \end{DoxyPre}
 


\begin{DoxyParams}{Parameters}
{\em images} & Source arrays. They all should have the same depth, C\+V\+\_\+8U, C\+V\+\_\+16U or C\+V\+\_\+32F , and the same size. Each of them can have an arbitrary number of channels. \\
\hline
{\em nimages} & Number of source images. \\
\hline
{\em channels} & List of the dims channels used to compute the histogram. The first array channels are numerated from 0 to images\mbox{[}0\mbox{]}.channels()-\/1 , the second array channels are counted from images\mbox{[}0\mbox{]}.channels() to images\mbox{[}0\mbox{]}.channels() + images\mbox{[}1\mbox{]}.channels()-\/1, and so on. \\
\hline
{\em mask} & Optional mask. If the matrix is not empty, it must be an 8-\/bit array of the same size as images\mbox{[}i\mbox{]} . The non-\/zero mask elements mark the array elements counted in the histogram. \\
\hline
{\em hist} & Output histogram, which is a dense or sparse dims -\/dimensional array. \\
\hline
{\em dims} & Histogram dimensionality that must be positive and not greater than C\+V\+\_\+\+M\+A\+X\+\_\+\+D\+I\+MS (equal to 32 in the current Open\+CV version). \\
\hline
{\em hist\+Size} & Array of histogram sizes in each dimension. \\
\hline
{\em ranges} & Array of the dims arrays of the histogram bin boundaries in each dimension. When the histogram is uniform ( uniform =true), then for each dimension i it is enough to specify the lower (inclusive) boundary $L_0$ of the 0-\/th histogram bin and the upper (exclusive) boundary $U_{\texttt{histSize}[i]-1}$ for the last histogram bin hist\+Size\mbox{[}i\mbox{]}-\/1 . That is, in case of a uniform histogram each of ranges\mbox{[}i\mbox{]} is an array of 2 elements. When the histogram is not uniform ( uniform=false ), then each of ranges\mbox{[}i\mbox{]} contains hist\+Size\mbox{[}i\mbox{]}+1 elements\+: $L_0, U_0=L_1, U_1=L_2, ..., U_{\texttt{histSize[i]}-2}=L_{\texttt{histSize[i]}-1}, U_{\texttt{histSize[i]}-1}$ . The array elements, that are not between $L_0$ and $U_{\texttt{histSize[i]}-1}$ , are not counted in the histogram. \\
\hline
{\em uniform} & Flag indicating whether the histogram is uniform or not (see above). \\
\hline
{\em accumulate} & Accumulation flag. If it is set, the histogram is not cleared in the beginning when it is allocated. This feature enables you to compute a single histogram from several sets of arrays, or to update the histogram in time. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__hist_ga09dcede19ebb0d3cc41d719fa761849c}\label{group__imgproc__hist_ga09dcede19ebb0d3cc41d719fa761849c}} 
\index{Histograms@{Histograms}!calc\+Hist@{calc\+Hist}}
\index{calc\+Hist@{calc\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Hist()}{calcHist()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist (\begin{DoxyParamCaption}\item[{@Const Mat}]{images,  }\item[{int}]{nimages,  }\item[{@Const Int\+Pointer}]{channels,  }\item[{@By\+Val Mat}]{mask,  }\item[{@By\+Ref Sparse\+Mat}]{hist,  }\item[{int}]{dims,  }\item[{@Const Int\+Pointer}]{hist\+Size,  }\item[{@Cast(\char`\"{}const float$\ast$$\ast$\char`\"{}) Pointer\+Pointer}]{ranges,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{uniform,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{accumulate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

this variant uses cv\+::\+Sparse\+Mat for output \mbox{\Hypertarget{group__imgproc__hist_gaae5adf8a34c06197b68e79d8dcb9c9fd}\label{group__imgproc__hist_gaae5adf8a34c06197b68e79d8dcb9c9fd}} 
\index{Histograms@{Histograms}!calc\+Hist@{calc\+Hist}}
\index{calc\+Hist@{calc\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{calc\+Hist()}{calcHist()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+calc\+Hist (\begin{DoxyParamCaption}\item[{@By\+Val Mat\+Vector}]{images,  }\item[{@Std\+Vector Int\+Pointer}]{channels,  }\item[{@By\+Val Mat}]{mask,  }\item[{@By\+Val Mat}]{hist,  }\item[{@Std\+Vector Int\+Pointer}]{hist\+Size,  }\item[{@Std\+Vector Float\+Pointer}]{ranges,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{accumulate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__hist_ga2c5a33af2393e75272a7346241822627}\label{group__imgproc__hist_ga2c5a33af2393e75272a7346241822627}} 
\index{Histograms@{Histograms}!compare\+Hist@{compare\+Hist}}
\index{compare\+Hist@{compare\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{compare\+Hist()}{compareHist()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+compare\+Hist (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{H1,  }\item[{@By\+Val Mat}]{H2,  }\item[{int}]{method }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Compares two histograms. 

The function cv\+::compare\+Hist compares two dense or two sparse histograms using the specified method. 

The function returns $d(H_1, H_2)$ . 

While the function works well with 1-\/, 2-\/, 3-\/dimensional dense histograms, it may not be suitable for high-\/dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-\/zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the cv\+::\+E\+MD function. 


\begin{DoxyParams}{Parameters}
{\em H1} & First compared histogram. \\
\hline
{\em H2} & Second compared histogram of the same size as H1 . \\
\hline
{\em method} & Comparison method, see cv\+::\+Hist\+Comp\+Methods \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__hist_gadc2285df53903ac40eb1f3ac72136eb1}\label{group__imgproc__hist_gadc2285df53903ac40eb1f3ac72136eb1}} 
\index{Histograms@{Histograms}!compare\+Hist@{compare\+Hist}}
\index{compare\+Hist@{compare\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{compare\+Hist()}{compareHist()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+compare\+Hist (\begin{DoxyParamCaption}\item[{@Const @By\+Ref Sparse\+Mat}]{H1,  }\item[{@Const @By\+Ref Sparse\+Mat}]{H2,  }\item[{int}]{method }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__hist_ga754ea5294cd28cb142b11116e1c4d658}\label{group__imgproc__hist_ga754ea5294cd28cb142b11116e1c4d658}} 
\index{Histograms@{Histograms}!E\+MD@{E\+MD}}
\index{E\+MD@{E\+MD}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{E\+M\+D()}{EMD()}}
{\footnotesize\ttfamily static native float org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+E\+MD (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{signature1,  }\item[{@By\+Val Mat}]{signature2,  }\item[{int}]{dist\+Type,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Input\+Array(cv\+::no\+Array())\char`\"{}) Mat}]{cost,  }\item[{Float\+Pointer}]{lower\+Bound,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+Output\+Array(cv\+::no\+Array())\char`\"{}) Mat}]{flow }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Computes the \char`\"{}minimal work\char`\"{} distance between two weighted point configurations. 

The function computes the earth mover distance and/or a lower boundary of the distance between the two weighted point configurations. One of the applications described in {\bfseries [Rubner\+Sept98]}, {\bfseries [Rubner2000]} is multi-\/dimensional histogram comparison for image retrieval. E\+MD is a transportation problem that is solved using some modification of a simplex algorithm, thus the complexity is exponential in the worst case, though, on average it is much faster. In the case of a real metric the lower boundary can be calculated even faster (using linear-\/time algorithm) and it can be used to determine roughly whether the two signatures are far enough so that they cannot relate to the same object. 


\begin{DoxyParams}{Parameters}
{\em signature1} & First signature, a $\texttt{size1}\times \texttt{dims}+1$ floating-\/point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-\/defined cost matrix is used. The weights must be non-\/negative and have at least one non-\/zero value. \\
\hline
{\em signature2} & Second signature of the same format as signature1 , though the number of rows may be different. The total weights may be different. In this case an extra \char`\"{}dummy\char`\"{} point is added to either signature1 or signature2. The weights must be non-\/negative and have at least one non-\/zero value. \\
\hline
{\em dist\+Type} & Used metric. See cv\+::\+Distance\+Types. \\
\hline
{\em cost} & User-\/defined $\texttt{size1}\times \texttt{size2}$ cost matrix. Also, if a cost matrix is used, lower boundary lower\+Bound cannot be calculated because it needs a metric function. \\
\hline
{\em lower\+Bound} & Optional input/output parameter\+: lower boundary of a distance between the two signatures that is a distance between mass centers. The lower boundary may not be calculated if the user-\/defined cost matrix is used, the total weights of point configurations are not equal, or if the signatures consist of weights only (the signature matrices have a single column). You must$\ast$$\ast$ initialize $\ast$lower\+Bound . If the calculated distance between mass centers is greater or equal to $\ast$lower\+Bound (it means that the signatures are far enough), the function does not calculate E\+MD. In any case $\ast$lower\+Bound is set to the calculated distance between mass centers on return. Thus, if you want to calculate both distance between mass centers and E\+MD, $\ast$lower\+Bound should be set to 0. \\
\hline
{\em flow} & Resultant $\texttt{size1} \times \texttt{size2}$ flow matrix\+: $\texttt{flow}_{i,j}$ is a flow from $i$ -\/th point of signature1 to $j$ -\/th point of signature2 . \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__hist_gabfd0825b3947af498b1eecc64de2787c}\label{group__imgproc__hist_gabfd0825b3947af498b1eecc64de2787c}} 
\index{Histograms@{Histograms}!equalize\+Hist@{equalize\+Hist}}
\index{equalize\+Hist@{equalize\+Hist}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{equalize\+Hist()}{equalizeHist()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+equalize\+Hist (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{src,  }\item[{@By\+Val Mat}]{dst }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Equalizes the histogram of a grayscale image. 

The function equalizes the histogram of the input image using the following algorithm\+: 


\begin{DoxyItemize}
\item Calculate the histogram $H$ for src .
\item Normalize the histogram so that the sum of histogram bins is 255.
\item Compute the integral of the histogram\+: \[H'_i = \sum _{0 \le j < i} H(j)\]
\item Transform the image using $H'$ as a look-\/up table\+: $\texttt{dst}(x,y) = H'(\texttt{src}(x,y))$ 
\end{DoxyItemize}

The algorithm normalizes the brightness and increases the contrast of the image. 


\begin{DoxyParams}{Parameters}
{\em src} & Source 8-\/bit single channel image. \\
\hline
{\em dst} & Destination image of the same size and type as src . \\
\hline
\end{DoxyParams}


\subsection{Variable Documentation}
\mbox{\Hypertarget{group__imgproc__hist_ga191607eeab47aa090f1b49b4e1198f6a}\label{group__imgproc__hist_ga191607eeab47aa090f1b49b4e1198f6a}} 
\index{Histograms@{Histograms}!H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL@{H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL}}
\index{H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL@{H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL}!Histograms@{Histograms}}
\subsubsection{\texorpdfstring{H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL}{HISTCMP\_CORREL}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+H\+I\+S\+T\+C\+M\+P\+\_\+\+C\+O\+R\+R\+EL = 0\hspace{0.3cm}{\ttfamily [static]}}

Histogram comparison methodsenum cv\+::\+Hist\+Comp\+Methods Correlation \[d(H_1,H_2) = \frac{\sum_I (H_1(I) - \bar{H_1}) (H_2(I) - \bar{H_2})}{\sqrt{\sum_I(H_1(I) - \bar{H_1})^2 \sum_I(H_2(I) - \bar{H_2})^2}}\] where \[\bar{H_k} = \frac{1}{N} \sum _J H_k(J)\] and $N$ is a total number of histogram bins. 