\hypertarget{group__imgproc__shape}{}\section{Structural Analysis and Shape Descriptors}
\label{group__imgproc__shape}\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}


Calculates all of the moments up to the third order of a polygon or rasterized shape.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga587e64de803dabd38ca391a03a5f4fd9}\label{group__imgproc__shape_ga587e64de803dabd38ca391a03a5f4fd9}} 
static native Moments {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+moments} ( @By\+Val Mat array, @Cast(\char`\"{}bool\char`\"{}) boolean binary\+Image)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gaf7a71880cce7ac26c76cfa0b714d8d0b}\label{group__imgproc__shape_gaf7a71880cce7ac26c76cfa0b714d8d0b}} 
static native Moments {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+moments} ( @By\+Val Mat array)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga91d21ed02d573681edb3ea58cf061a54}\label{group__imgproc__shape_ga91d21ed02d573681edb3ea58cf061a54}} 
static native Moments {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+moments} ( @By\+Val U\+Mat array, @Cast(\char`\"{}bool\char`\"{}) boolean binary\+Image)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga9c86bca4a90148aedbe9e0f389918234}\label{group__imgproc__shape_ga9c86bca4a90148aedbe9e0f389918234}} 
static native Moments {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+moments} ( @By\+Val U\+Mat array)
\item 
static native void \hyperlink{group__imgproc__shape_ga352b5f00f51966f12301dfd255d06189}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments} ( @Const @By\+Ref Moments moments, Double\+Pointer hu)
\begin{DoxyCompactList}\small\item\em Calculates seven Hu invariants. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga1ebf2fbe5589d86cd6b582b4c1b0099f}\label{group__imgproc__shape_ga1ebf2fbe5589d86cd6b582b4c1b0099f}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments} ( @Const @By\+Ref Moments moments, Double\+Buffer hu)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gaf04e38d3d23a62bbdbf314e5cb12d696}\label{group__imgproc__shape_gaf04e38d3d23a62bbdbf314e5cb12d696}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments} ( @Const @By\+Ref Moments moments, double\mbox{[}$\,$\mbox{]} hu)
\item 
static native void \hyperlink{group__imgproc__shape_gab567ad055b6ac17d75b8f78044f7c2d4}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments} ( @Const @By\+Ref Moments m, @By\+Val Mat hu)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga82b6c9f75c3cfd7c3bfb8d5c676c2912}\label{group__imgproc__shape_ga82b6c9f75c3cfd7c3bfb8d5c676c2912}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments} ( @Const @By\+Ref Moments m, @By\+Val U\+Mat hu)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga4e8ed08a584f1336f7dc27480b84e59c}\label{group__imgproc__shape_ga4e8ed08a584f1336f7dc27480b84e59c}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Algorithm} (@By\+Val Mat image, @By\+Val Mat labels, int connectivity, int ltype, int ccltype)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga5ff9117322f7e9a06bd574b4e7ccaca3}\label{group__imgproc__shape_ga5ff9117322f7e9a06bd574b4e7ccaca3}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Algorithm} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels, int connectivity, int ltype, int ccltype)
\item 
static native int \hyperlink{group__imgproc__shape_gad3b372e7de7a736c55ae6707238019cf}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components} (@By\+Val Mat image, @By\+Val Mat labels, int connectivity, int ltype)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gac4ef28d9919a94c3d6c03735cdc7ecf6}\label{group__imgproc__shape_gac4ef28d9919a94c3d6c03735cdc7ecf6}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components} (@By\+Val Mat image, @By\+Val Mat labels)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga5d63d5173052c0ffe58d32ece0243b02}\label{group__imgproc__shape_ga5d63d5173052c0ffe58d32ece0243b02}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels, int connectivity, int ltype)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga6bf59a9541c5c2d1ee90b91d817d8dfd}\label{group__imgproc__shape_ga6bf59a9541c5c2d1ee90b91d817d8dfd}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels)
\item 
static native int \hyperlink{group__imgproc__shape_gaed0a27b064f9360aa2cdfc5368f6c81c}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats\+With\+Algorithm} (@By\+Val Mat image, @By\+Val Mat labels, @By\+Val Mat stats, @By\+Val Mat centroids, int connectivity, int ltype, int ccltype)
\begin{DoxyCompactList}\small\item\em computes the connected components labeled image of boolean image and also produces a statistics output for each label \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_gabccfc57abcae8bb4a852270232ef9b05}\label{group__imgproc__shape_gabccfc57abcae8bb4a852270232ef9b05}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats\+With\+Algorithm} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels, @By\+Val U\+Mat stats, @By\+Val U\+Mat centroids, int connectivity, int ltype, int ccltype)
\item 
static native int \hyperlink{group__imgproc__shape_gab229ea94bd41ec2bbcda17ba9d2968fe}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats} (@By\+Val Mat image, @By\+Val Mat labels, @By\+Val Mat stats, @By\+Val Mat centroids, int connectivity, int ltype)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga63ef30500bff6a4af684eee1b3c029f6}\label{group__imgproc__shape_ga63ef30500bff6a4af684eee1b3c029f6}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats} (@By\+Val Mat image, @By\+Val Mat labels, @By\+Val Mat stats, @By\+Val Mat centroids)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga758d9571a7535f1ca26b646ed582b4e9}\label{group__imgproc__shape_ga758d9571a7535f1ca26b646ed582b4e9}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels, @By\+Val U\+Mat stats, @By\+Val U\+Mat centroids, int connectivity, int ltype)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gac47f114fe47546f5da3b8dc995c35db1}\label{group__imgproc__shape_gac47f114fe47546f5da3b8dc995c35db1}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats} (@By\+Val U\+Mat image, @By\+Val U\+Mat labels, @By\+Val U\+Mat stats, @By\+Val U\+Mat centroids)
\item 
static native void \hyperlink{group__imgproc__shape_gad95c6aa001eb4a24cc898ff08dcb81da}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val Mat\+Vector contours, @By\+Val Mat hierarchy, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\begin{DoxyCompactList}\small\item\em Finds contours in a binary image. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_gaa4fa757d554fd45a740f5348bd3ee282}\label{group__imgproc__shape_gaa4fa757d554fd45a740f5348bd3ee282}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val Mat\+Vector contours, @By\+Val Mat hierarchy, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gad9536bf2310f484d496884d21937ea79}\label{group__imgproc__shape_gad9536bf2310f484d496884d21937ea79}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val U\+Mat\+Vector contours, @By\+Val Mat hierarchy, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gaf0ff0f9dfae455c9440b756d598f4b2b}\label{group__imgproc__shape_gaf0ff0f9dfae455c9440b756d598f4b2b}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val U\+Mat\+Vector contours, @By\+Val Mat hierarchy, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga26b5d7abef556a54da3c295fe355a1e1}\label{group__imgproc__shape_ga26b5d7abef556a54da3c295fe355a1e1}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val Mat\+Vector contours, @By\+Val U\+Mat hierarchy, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga475333c1bd51ec2b3c72f5849c294ce2}\label{group__imgproc__shape_ga475333c1bd51ec2b3c72f5849c294ce2}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val Mat\+Vector contours, @By\+Val U\+Mat hierarchy, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga666cc59514d27b672aa1e7d6942b7f98}\label{group__imgproc__shape_ga666cc59514d27b672aa1e7d6942b7f98}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val U\+Mat\+Vector contours, @By\+Val U\+Mat hierarchy, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga6ef8f480fda759a0611e6a3f4660e520}\label{group__imgproc__shape_ga6ef8f480fda759a0611e6a3f4660e520}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val U\+Mat\+Vector contours, @By\+Val U\+Mat hierarchy, int mode, int method)
\item 
static native void \hyperlink{group__imgproc__shape_ga9242b107e02badf32d704830cda84585}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val Mat\+Vector contours, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga902eb6627cfe9fe9909503672730d0f5}\label{group__imgproc__shape_ga902eb6627cfe9fe9909503672730d0f5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val Mat\+Vector contours, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga0d4a57c0961e15ad326f3cffb2005621}\label{group__imgproc__shape_ga0d4a57c0961e15ad326f3cffb2005621}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val U\+Mat\+Vector contours, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga7e50eb8f5267eacbdc6b9b222c7934fc}\label{group__imgproc__shape_ga7e50eb8f5267eacbdc6b9b222c7934fc}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val Mat image, @By\+Val U\+Mat\+Vector contours, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga6cfd4f0c2df93afd8eeb329c719ac9fd}\label{group__imgproc__shape_ga6cfd4f0c2df93afd8eeb329c719ac9fd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val Mat\+Vector contours, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga8ea1fd66bd5d44f0f7fe9df754847086}\label{group__imgproc__shape_ga8ea1fd66bd5d44f0f7fe9df754847086}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val Mat\+Vector contours, int mode, int method)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga9b9d5914bec73025c51f73c6e1f189dc}\label{group__imgproc__shape_ga9b9d5914bec73025c51f73c6e1f189dc}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val U\+Mat\+Vector contours, int mode, int method, @By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point offset)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga4c289193c5c5377d64ceb90e41ee5e78}\label{group__imgproc__shape_ga4c289193c5c5377d64ceb90e41ee5e78}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours} ( @By\+Val U\+Mat image, @By\+Val U\+Mat\+Vector contours, int mode, int method)
\item 
static native void \hyperlink{group__imgproc__shape_ga59b2a13c4f741e0898f8415d9436d8a0}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+approx\+Poly\+DP} ( @By\+Val Mat curve, @By\+Val Mat approx\+Curve, double epsilon, @Cast(\char`\"{}bool\char`\"{}) boolean closed)
\begin{DoxyCompactList}\small\item\em Approximates a polygonal curve(s) with the specified precision. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga53cc7853fbb42e0adb50e055b06aed60}\label{group__imgproc__shape_ga53cc7853fbb42e0adb50e055b06aed60}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+approx\+Poly\+DP} ( @By\+Val U\+Mat curve, @By\+Val U\+Mat approx\+Curve, double epsilon, @Cast(\char`\"{}bool\char`\"{}) boolean closed)
\item 
static native double \hyperlink{group__imgproc__shape_gad6c8dc05432d5351a7480042bbbbe328}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+arc\+Length} ( @By\+Val Mat curve, @Cast(\char`\"{}bool\char`\"{}) boolean closed)
\begin{DoxyCompactList}\small\item\em Calculates a contour perimeter or a curve length. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga1cdab039b5a1b5d3c72eed7fcb024319}\label{group__imgproc__shape_ga1cdab039b5a1b5d3c72eed7fcb024319}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+arc\+Length} ( @By\+Val U\+Mat curve, @Cast(\char`\"{}bool\char`\"{}) boolean closed)
\item 
static native Rect \hyperlink{group__imgproc__shape_ga8e749f0c2a90af2956b90b60689d6602}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bounding\+Rect} ( @By\+Val Mat points)
\begin{DoxyCompactList}\small\item\em Calculates the up-\/right bounding rectangle of a point set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_gacafd59dde2f78776d5dc39328cd5da3a}\label{group__imgproc__shape_gacafd59dde2f78776d5dc39328cd5da3a}} 
static native Rect {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bounding\+Rect} ( @By\+Val U\+Mat points)
\item 
static native double \hyperlink{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+contour\+Area} ( @By\+Val Mat contour, @Cast(\char`\"{}bool\char`\"{}) boolean oriented)
\begin{DoxyCompactList}\small\item\em Calculates a contour area. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga63665109365ae695072d4ba834f95bbb}\label{group__imgproc__shape_ga63665109365ae695072d4ba834f95bbb}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+contour\+Area} ( @By\+Val Mat contour)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga8c4e4c69db5ec099b7c3431e05a6ce84}\label{group__imgproc__shape_ga8c4e4c69db5ec099b7c3431e05a6ce84}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+contour\+Area} ( @By\+Val U\+Mat contour, @Cast(\char`\"{}bool\char`\"{}) boolean oriented)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga0cfde91590f81f0544f40ea3ce2c51bb}\label{group__imgproc__shape_ga0cfde91590f81f0544f40ea3ce2c51bb}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+contour\+Area} ( @By\+Val U\+Mat contour)
\item 
static native Rotated\+Rect \hyperlink{group__imgproc__shape_gae621046d95a8ba9f1e1ce112ab8de61a}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Area\+Rect} ( @By\+Val Mat points)
\begin{DoxyCompactList}\small\item\em Finds a rotated rectangle of the minimum area enclosing the input 2D point set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga2fcdb1e9ccc31aca2f77dc8812752879}\label{group__imgproc__shape_ga2fcdb1e9ccc31aca2f77dc8812752879}} 
static native Rotated\+Rect {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Area\+Rect} ( @By\+Val U\+Mat points)
\item 
static native void \hyperlink{group__imgproc__shape_ga02ee8d410547c387ed348bbb9c2fc213}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Points} (@By\+Val Rotated\+Rect box, @By\+Val Mat points)
\begin{DoxyCompactList}\small\item\em Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga7e1db9a4fe383c8f67a82ffbba7d95bd}\label{group__imgproc__shape_ga7e1db9a4fe383c8f67a82ffbba7d95bd}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Points} (@By\+Val Rotated\+Rect box, @By\+Val U\+Mat points)
\item 
static native void \hyperlink{group__imgproc__shape_ga6247e734952a578322d69260230c4a41}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Circle} ( @By\+Val Mat points, @By\+Ref Point2f center, @By\+Ref Float\+Pointer radius)
\begin{DoxyCompactList}\small\item\em Finds a circle of the minimum area enclosing a 2D point set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_gabdaa1e45e74a5477785134bcfa3ecab3}\label{group__imgproc__shape_gabdaa1e45e74a5477785134bcfa3ecab3}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Circle} ( @By\+Val Mat points, @By\+Ref Point2f center, @By\+Ref Float\+Buffer radius)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gab36f58950767d263b969b501edac30d8}\label{group__imgproc__shape_gab36f58950767d263b969b501edac30d8}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Circle} ( @By\+Val U\+Mat points, @By\+Ref Point2f center, @By\+Ref float\mbox{[}$\,$\mbox{]} radius)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga9b12d377ced761a1de491682b6e98e8b}\label{group__imgproc__shape_ga9b12d377ced761a1de491682b6e98e8b}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Circle} ( @By\+Val U\+Mat points, @By\+Ref Point2f center, @By\+Ref Float\+Pointer radius)
\item 
static native double \hyperlink{group__imgproc__shape_ga789d0feac6b1ff1a2d13cfc58fa3e898}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Triangle} ( @By\+Val Mat points, @By\+Val Mat triangle)
\begin{DoxyCompactList}\small\item\em Finds a triangle of minimum area enclosing a 2D point set and returns its area. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga632c3862bf6f37ac50afb3b2cf530d7e}\label{group__imgproc__shape_ga632c3862bf6f37ac50afb3b2cf530d7e}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Triangle} ( @By\+Val U\+Mat points, @By\+Val U\+Mat triangle)
\item 
static native double \hyperlink{group__imgproc__shape_gad14ba9809a9703bef3dbdcd1a487d2fb}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+match\+Shapes} ( @By\+Val Mat contour1, @By\+Val Mat contour2, int method, double parameter)
\begin{DoxyCompactList}\small\item\em Compares two shapes. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga802fec5d9e13b63c134ade0e920fe7cb}\label{group__imgproc__shape_ga802fec5d9e13b63c134ade0e920fe7cb}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+match\+Shapes} ( @By\+Val U\+Mat contour1, @By\+Val U\+Mat contour2, int method, double parameter)
\item 
static native void \hyperlink{group__imgproc__shape_gad55038a508ccdb2a51346a9321039983}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convex\+Hull} ( @By\+Val Mat points, @By\+Val Mat hull, @Cast(\char`\"{}bool\char`\"{}) boolean clockwise, @Cast(\char`\"{}bool\char`\"{}) boolean return\+Points)
\begin{DoxyCompactList}\small\item\em Finds the convex hull of a point set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga3ca5756bf3c700d741f008a5ee28f49a}\label{group__imgproc__shape_ga3ca5756bf3c700d741f008a5ee28f49a}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convex\+Hull} ( @By\+Val Mat points, @By\+Val Mat hull)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gac7226745217acd7ef4d6298ef30c0600}\label{group__imgproc__shape_gac7226745217acd7ef4d6298ef30c0600}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convex\+Hull} ( @By\+Val U\+Mat points, @By\+Val U\+Mat hull, @Cast(\char`\"{}bool\char`\"{}) boolean clockwise, @Cast(\char`\"{}bool\char`\"{}) boolean return\+Points)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gad3606f6f4a3d715eeb5ecb41e95b6e3e}\label{group__imgproc__shape_gad3606f6f4a3d715eeb5ecb41e95b6e3e}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convex\+Hull} ( @By\+Val U\+Mat points, @By\+Val U\+Mat hull)
\item 
static native void \hyperlink{group__imgproc__shape_ga5947a188964bc225faa41c8281dd16a4}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convexity\+Defects} ( @By\+Val Mat contour, @By\+Val Mat convexhull, @By\+Val Mat convexity\+Defects)
\begin{DoxyCompactList}\small\item\em Finds the convexity defects of a contour. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga966bc37c9cf3731f716461c3ac5820c5}\label{group__imgproc__shape_ga966bc37c9cf3731f716461c3ac5820c5}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convexity\+Defects} ( @By\+Val U\+Mat contour, @By\+Val U\+Mat convexhull, @By\+Val U\+Mat convexity\+Defects)
\item 
static native boolean \hyperlink{group__imgproc__shape_gad00ac2d87b83a753b5edcdbb2daf526f}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+is\+Contour\+Convex} ( @By\+Val Mat contour)
\begin{DoxyCompactList}\small\item\em Tests a contour convexity. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga8189ade3a7d61fb8ceb6ab782007112b}\label{group__imgproc__shape_ga8189ade3a7d61fb8ceb6ab782007112b}} 
static native boolean {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+is\+Contour\+Convex} ( @By\+Val U\+Mat contour)
\item 
static native float \hyperlink{group__imgproc__shape_ga1664076df6a9c8e2780c3650b12551a1}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+intersect\+Convex\+Convex} ( @By\+Val Mat \+\_\+p1, @By\+Val Mat \+\_\+p2, @By\+Val Mat \+\_\+p12, @Cast(\char`\"{}bool\char`\"{}) boolean handle\+Nested)
\item 
\mbox{\Hypertarget{group__imgproc__shape_gada15f5267d8e5a7fbd89874f6442c785}\label{group__imgproc__shape_gada15f5267d8e5a7fbd89874f6442c785}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+intersect\+Convex\+Convex} ( @By\+Val Mat \+\_\+p1, @By\+Val Mat \+\_\+p2, @By\+Val Mat \+\_\+p12)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga7a1d0ab280a855959142c809ec18874c}\label{group__imgproc__shape_ga7a1d0ab280a855959142c809ec18874c}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+intersect\+Convex\+Convex} ( @By\+Val U\+Mat \+\_\+p1, @By\+Val U\+Mat \+\_\+p2, @By\+Val U\+Mat \+\_\+p12, @Cast(\char`\"{}bool\char`\"{}) boolean handle\+Nested)
\item 
\mbox{\Hypertarget{group__imgproc__shape_ga9e788b99eb471cf0511dfdbad7b6ce23}\label{group__imgproc__shape_ga9e788b99eb471cf0511dfdbad7b6ce23}} 
static native float {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+intersect\+Convex\+Convex} ( @By\+Val U\+Mat \+\_\+p1, @By\+Val U\+Mat \+\_\+p2, @By\+Val U\+Mat \+\_\+p12)
\item 
static native Rotated\+Rect \hyperlink{group__imgproc__shape_ga4e705f42eefa1224c87285653b6fb44d}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Ellipse} ( @By\+Val Mat points)
\begin{DoxyCompactList}\small\item\em Fits an ellipse around a set of 2D points. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga4e86533eab74a1f956cd1db026edf8ed}\label{group__imgproc__shape_ga4e86533eab74a1f956cd1db026edf8ed}} 
static native Rotated\+Rect {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Ellipse} ( @By\+Val U\+Mat points)
\item 
static native void \hyperlink{group__imgproc__shape_ga081f0e410b01a81bbfe62c828ebb3c6f}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Line} ( @By\+Val Mat points, @By\+Val Mat line, int dist\+Type, double param, double reps, double aeps)
\begin{DoxyCompactList}\small\item\em Fits a line to a 2D or 3D point set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga6833c0216cb9d8be1efa71dbbd31db72}\label{group__imgproc__shape_ga6833c0216cb9d8be1efa71dbbd31db72}} 
static native void {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Line} ( @By\+Val U\+Mat points, @By\+Val U\+Mat line, int dist\+Type, double param, double reps, double aeps)
\item 
static native double \hyperlink{group__imgproc__shape_gaf6f02003be04d7a37eff3af25946ff77}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+point\+Polygon\+Test} ( @By\+Val Mat contour, @By\+Val Point2f pt, @Cast(\char`\"{}bool\char`\"{}) boolean measure\+Dist)
\begin{DoxyCompactList}\small\item\em Performs a point-\/in-\/contour test. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_gab9b42bbdf409f7a8080d8fd2330dc8df}\label{group__imgproc__shape_gab9b42bbdf409f7a8080d8fd2330dc8df}} 
static native double {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+point\+Polygon\+Test} ( @By\+Val U\+Mat contour, @By\+Val Point2f pt, @Cast(\char`\"{}bool\char`\"{}) boolean measure\+Dist)
\item 
static native int \hyperlink{group__imgproc__shape_gadcfa20fed89c804a31f05ae6e1023379}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+rotated\+Rectangle\+Intersection} ( @Const @By\+Ref Rotated\+Rect rect1, @Const @By\+Ref Rotated\+Rect rect2, @By\+Val Mat intersecting\+Region)
\begin{DoxyCompactList}\small\item\em Finds out if there is any intersection between two rotated rectangles. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__imgproc__shape_ga3b6f1be65a6265484440e694bcf84f90}\label{group__imgproc__shape_ga3b6f1be65a6265484440e694bcf84f90}} 
static native int {\bfseries org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+rotated\+Rectangle\+Intersection} ( @Const @By\+Ref Rotated\+Rect rect1, @Const @By\+Ref Rotated\+Rect rect2, @By\+Val U\+Mat intersecting\+Region)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static final int \hyperlink{group__imgproc__shape_ga349952fcbf280ca92c36978312c607a6}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT} = 0
\item 
static final int \hyperlink{group__imgproc__shape_ga9b0d3771ada15612aef51a25db60c21f}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+C\+L\+\_\+\+WU} = 0
\item 
static final int \hyperlink{group__imgproc__shape_ga94d7307a24949485303f94d555fd31c8}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL} = 0
\item 
static final int \hyperlink{group__imgproc__shape_ga2e9681fae693a35abe17e8f4265acdbf}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE} = 1
\item 
static final int \hyperlink{group__imgproc__shape_gae1ca9924d0a73e52ad45f660cc2160e4}{org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Calculates all of the moments up to the third order of a polygon or rasterized shape. 

computes the connected components labeled image of boolean image

imgproc\+\_\+misc 

connected components algorithm output formats

/$\ast$$\ast$

The function computes moments, up to the 3rd order, of a vector shape or a rasterized shape. The results are returned in the structure cv\+::\+Moments. 


\begin{DoxyParams}{Parameters}
{\em array} & Raster image (single-\/channel, 8-\/bit or floating-\/point 2D array) or an array ( $1 \times N$ or $N \times 1$ ) of 2D points (fr.antproject.utils.Point or Point2f ). \\
\hline
{\em binary\+Image} & If it is true, all non-\/zero image pixels are treated as 1\textquotesingle{}s. The parameter is used for images only. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
moments. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Only applicable to contour moments calculations from Python bindings\+: Note that the numpy type for the input array should be either np.\+int32 or np.\+float32. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}{contour\+Area}, \hyperlink{group__imgproc__shape_gad6c8dc05432d5351a7480042bbbbe328}{arc\+Length}
\end{DoxySeeAlso}


/$\ast$$\ast$

image with 4 or 8 way connectivity -\/ returns N, the total number of labels \mbox{[}0, N-\/1\mbox{]} where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana\textquotesingle{}s (B\+B\+DT) and Wu\textquotesingle{}s (S\+A\+UF) algorithms are supported, see the cv\+::\+Connected\+Components\+Algorithms\+Types for details. Note that S\+A\+UF algorithm forces a row major ordering of labels while B\+B\+DT does not. 


\begin{DoxyParams}{Parameters}
{\em image} & the 8-\/bit single-\/channel image to be labeled \\
\hline
{\em labels} & destination labeled image \\
\hline
{\em connectivity} & 8 or 4 for 8-\/way or 4-\/way connectivity respectively \\
\hline
{\em ltype} & output image label type. Currently C\+V\+\_\+32S and C\+V\+\_\+16U are supported. \\
\hline
{\em ccltype} & connected components algorithm type (see the cv\+::\+Connected\+Components\+Algorithms\+Types). \\
\hline
\end{DoxyParams}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__imgproc__shape_ga59b2a13c4f741e0898f8415d9436d8a0}\label{group__imgproc__shape_ga59b2a13c4f741e0898f8415d9436d8a0}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!approx\+Poly\+DP@{approx\+Poly\+DP}}
\index{approx\+Poly\+DP@{approx\+Poly\+DP}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{approx\+Poly\+D\+P()}{approxPolyDP()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+approx\+Poly\+DP (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{curve,  }\item[{@By\+Val Mat}]{approx\+Curve,  }\item[{double}]{epsilon,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{closed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Approximates a polygonal curve(s) with the specified precision. 

The function cv\+::approx\+Poly\+DP approximates a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-\/\+Peucker algorithm \href{http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Ramer-\/\+Douglas-\/\+Peucker\+\_\+algorithm} 


\begin{DoxyParams}{Parameters}
{\em curve} & Input vector of a 2D point stored in std\+::vector or Mat \\
\hline
{\em approx\+Curve} & Result of the approximation. The type should match the type of the input curve. \\
\hline
{\em epsilon} & Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation. \\
\hline
{\em closed} & If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gad6c8dc05432d5351a7480042bbbbe328}\label{group__imgproc__shape_gad6c8dc05432d5351a7480042bbbbe328}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!arc\+Length@{arc\+Length}}
\index{arc\+Length@{arc\+Length}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{arc\+Length()}{arcLength()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+arc\+Length (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{curve,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{closed }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates a contour perimeter or a curve length. 

The function computes a curve length or a closed contour perimeter. 


\begin{DoxyParams}{Parameters}
{\em curve} & Input vector of 2D points, stored in std\+::vector or Mat. \\
\hline
{\em closed} & Flag indicating whether the curve is closed or not. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga8e749f0c2a90af2956b90b60689d6602}\label{group__imgproc__shape_ga8e749f0c2a90af2956b90b60689d6602}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!bounding\+Rect@{bounding\+Rect}}
\index{bounding\+Rect@{bounding\+Rect}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{bounding\+Rect()}{boundingRect()}}
{\footnotesize\ttfamily static native Rect org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+bounding\+Rect (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates the up-\/right bounding rectangle of a point set. 

The function calculates and returns the minimal up-\/right bounding rectangle for the specified point set. 


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in std\+::vector or Mat. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga02ee8d410547c387ed348bbb9c2fc213}\label{group__imgproc__shape_ga02ee8d410547c387ed348bbb9c2fc213}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!box\+Points@{box\+Points}}
\index{box\+Points@{box\+Points}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{box\+Points()}{boxPoints()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+box\+Points (\begin{DoxyParamCaption}\item[{@By\+Val Rotated\+Rect}]{box,  }\item[{@By\+Val Mat}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle. 

The function finds the four vertices of a rotated rectangle. This function is useful to draw the rectangle. In C++, instead of using this function, you can directly use box.\+points() method. Please visit the \href{http://docs.opencv.org/doc/tutorials/imgproc/shapedescriptors/bounding_rects_circles/bounding_rects_circles.html#bounding-rects-circles}{\tt tutorial on bounding rectangle} for more information. 


\begin{DoxyParams}{Parameters}
{\em box} & The input rotated rectangle. It may be the output of \\
\hline
{\em points} & The output array of four vertices of rectangles. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gad3b372e7de7a736c55ae6707238019cf}\label{group__imgproc__shape_gad3b372e7de7a736c55ae6707238019cf}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!connected\+Components@{connected\+Components}}
\index{connected\+Components@{connected\+Components}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{connected\+Components()}{connectedComponents()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Val Mat}]{labels,  }\item[{int}]{connectivity,  }\item[{int}]{ltype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}{Parameters}
{\em image} & the 8-\/bit single-\/channel image to be labeled \\
\hline
{\em labels} & destination labeled image \\
\hline
{\em connectivity} & 8 or 4 for 8-\/way or 4-\/way connectivity respectively \\
\hline
{\em ltype} & output image label type. Currently C\+V\+\_\+32S and C\+V\+\_\+16U are supported. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gab229ea94bd41ec2bbcda17ba9d2968fe}\label{group__imgproc__shape_gab229ea94bd41ec2bbcda17ba9d2968fe}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!connected\+Components\+With\+Stats@{connected\+Components\+With\+Stats}}
\index{connected\+Components\+With\+Stats@{connected\+Components\+With\+Stats}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{connected\+Components\+With\+Stats()}{connectedComponentsWithStats()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Val Mat}]{labels,  }\item[{@By\+Val Mat}]{stats,  }\item[{@By\+Val Mat}]{centroids,  }\item[{int}]{connectivity,  }\item[{int}]{ltype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 
\begin{DoxyParams}{Parameters}
{\em image} & the 8-\/bit single-\/channel image to be labeled \\
\hline
{\em labels} & destination labeled image \\
\hline
{\em stats} & statistics output for each label, including the background label, see below for available statistics. Statistics are accessed via stats(label, C\+O\+L\+U\+M\+N) where C\+O\+L\+U\+MN is one of cv\+::\+Connected\+Components\+Types. The data type is C\+V\+\_\+32S. \\
\hline
{\em centroids} & centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type C\+V\+\_\+64F. \\
\hline
{\em connectivity} & 8 or 4 for 8-\/way or 4-\/way connectivity respectively \\
\hline
{\em ltype} & output image label type. Currently C\+V\+\_\+32S and C\+V\+\_\+16U are supported. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gaed0a27b064f9360aa2cdfc5368f6c81c}\label{group__imgproc__shape_gaed0a27b064f9360aa2cdfc5368f6c81c}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!connected\+Components\+With\+Stats\+With\+Algorithm@{connected\+Components\+With\+Stats\+With\+Algorithm}}
\index{connected\+Components\+With\+Stats\+With\+Algorithm@{connected\+Components\+With\+Stats\+With\+Algorithm}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{connected\+Components\+With\+Stats\+With\+Algorithm()}{connectedComponentsWithStatsWithAlgorithm()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+connected\+Components\+With\+Stats\+With\+Algorithm (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Val Mat}]{labels,  }\item[{@By\+Val Mat}]{stats,  }\item[{@By\+Val Mat}]{centroids,  }\item[{int}]{connectivity,  }\item[{int}]{ltype,  }\item[{int}]{ccltype }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



computes the connected components labeled image of boolean image and also produces a statistics output for each label 

image with 4 or 8 way connectivity -\/ returns N, the total number of labels \mbox{[}0, N-\/1\mbox{]} where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana\textquotesingle{}s (B\+B\+DT) and Wu\textquotesingle{}s (S\+A\+UF) algorithms are supported, see the cv\+::\+Connected\+Components\+Algorithms\+Types for details. Note that S\+A\+UF algorithm forces a row major ordering of labels while B\+B\+DT does not. 


\begin{DoxyParams}{Parameters}
{\em image} & the 8-\/bit single-\/channel image to be labeled \\
\hline
{\em labels} & destination labeled image \\
\hline
{\em stats} & statistics output for each label, including the background label, see below for available statistics. Statistics are accessed via stats(label, C\+O\+L\+U\+M\+N) where C\+O\+L\+U\+MN is one of cv\+::\+Connected\+Components\+Types. The data type is C\+V\+\_\+32S. \\
\hline
{\em centroids} & centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type C\+V\+\_\+64F. \\
\hline
{\em connectivity} & 8 or 4 for 8-\/way or 4-\/way connectivity respectively \\
\hline
{\em ltype} & output image label type. Currently C\+V\+\_\+32S and C\+V\+\_\+16U are supported. \\
\hline
{\em ccltype} & connected components algorithm type (see the cv\+::\+Connected\+Components\+Algorithms\+Types). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}\label{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!contour\+Area@{contour\+Area}}
\index{contour\+Area@{contour\+Area}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{contour\+Area()}{contourArea()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+contour\+Area (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{contour,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{oriented }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates a contour area. 

The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-\/zero pixels, if you draw the contour using draw\+Contours or fill\+Poly , can be different. Also, the function will most certainly give a wrong results for contours with self-\/intersections. 

Example\+: 
\begin{DoxyPre}
\begin{DoxyCode}
vector<fr.antproject.utils.Point> contour;
contour.push\_back(Point2f(0, 0));
contour.push\_back(Point2f(10, 0));
contour.push\_back(Point2f(10, 10));
contour.push\_back(Point2f(5, 4));

\textcolor{keywordtype}{double} area0 = \hyperlink{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}{contourArea}(contour);
vector<fr.antproject.utils.Point> approx;
\hyperlink{group__imgproc__shape_ga59b2a13c4f741e0898f8415d9436d8a0}{approxPolyDP}(contour, approx, 5, \textcolor{keyword}{true});
\textcolor{keywordtype}{double} area1 = \hyperlink{group__imgproc__shape_ga5de110872b0023d4176fcc7c3f2c6115}{contourArea}(approx);

cout << \textcolor{stringliteral}{"area0 ="} << area0 << endl <<
        \textcolor{stringliteral}{"area1 ="} << area1 << endl <<
        \textcolor{stringliteral}{"approx poly vertices"} << approx.size() << endl;
\end{DoxyCode}
 \end{DoxyPre}
 
\begin{DoxyParams}{Parameters}
{\em contour} & Input vector of 2D points (contour vertices), stored in std\+::vector or Mat. \\
\hline
{\em oriented} & Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-\/clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gad55038a508ccdb2a51346a9321039983}\label{group__imgproc__shape_gad55038a508ccdb2a51346a9321039983}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!convex\+Hull@{convex\+Hull}}
\index{convex\+Hull@{convex\+Hull}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{convex\+Hull()}{convexHull()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convex\+Hull (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points,  }\item[{@By\+Val Mat}]{hull,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{clockwise,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{return\+Points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds the convex hull of a point set. 

The function cv\+::convex\+Hull finds the convex hull of a 2D point set using the Sklansky\textquotesingle{}s algorithm {\bfseries [Sklansky82]} that has {\itshape O(\+N log\+N)} complexity in the current implementation. See the Open\+CV sample convexhull.\+cpp that demonstrates the usage of different function variants. 


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in std\+::vector or Mat. \\
\hline
{\em hull} & Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-\/based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves. \\
\hline
{\em clockwise} & Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-\/clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards. \\
\hline
{\em return\+Points} & Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std\+::vector, the flag is ignored, and the output depends on the type of the vector\+: std\+::vector$<$int$>$ implies return\+Points=false, std\+::vector$<$fr.antproject.utils.Point$>$ implies return\+Points=true. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga5947a188964bc225faa41c8281dd16a4}\label{group__imgproc__shape_ga5947a188964bc225faa41c8281dd16a4}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!convexity\+Defects@{convexity\+Defects}}
\index{convexity\+Defects@{convexity\+Defects}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{convexity\+Defects()}{convexityDefects()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+convexity\+Defects (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{contour,  }\item[{@By\+Val Mat}]{convexhull,  }\item[{@By\+Val Mat}]{convexity\+Defects }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds the convexity defects of a contour. 

The figure below displays convexity defects of a hand contour\+: 

 


\begin{DoxyParams}{Parameters}
{\em contour} & Input contour. \\
\hline
{\em convexhull} & Convex hull obtained using convex\+Hull that should contain indices of the contour points that make the hull. \\
\hline
{\em convexity\+Defects} & The output vector of convexity defects. In C++ and the new Python/\+Java interface each convexity defect is represented as 4-\/element integer vector (a.\+k.\+a. cv\+::\+Vec4i)\+: (start\+\_\+index, end\+\_\+index, farthest\+\_\+pt\+\_\+index, fixpt\+\_\+depth), where indices are 0-\/based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt\+\_\+depth is fixed-\/point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-\/point value of the depth will be fixpt\+\_\+depth/256.\+0. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gad95c6aa001eb4a24cc898ff08dcb81da}\label{group__imgproc__shape_gad95c6aa001eb4a24cc898ff08dcb81da}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!find\+Contours@{find\+Contours}}
\index{find\+Contours@{find\+Contours}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{find\+Contours()}{fr.antproject.utils.findContours()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Val Mat\+Vector}]{contours,  }\item[{@By\+Val Mat}]{hierarchy,  }\item[{int}]{mode,  }\item[{int}]{method,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds contours in a binary image. 

The function retrieves contours from the binary image using the algorithm {\bfseries [Suzuki85]} . The contours are a useful tool for shape analysis and object detection and recognition. See squares.\+cpp in the Open\+CV sample directory. 


\begin{DoxyParams}{Parameters}
{\em image} & Source, an 8-\/bit single-\/channel image. Non-\/zero pixels are treated as 1\textquotesingle{}s. Zero pixels remain 0\textquotesingle{}s, so the image is treated as binary . You can use cv\+::compare, cv\+::in\+Range, cv\+::fr.antproject.utils.threshold , cv\+::adaptive\+Threshold, cv\+::\+Canny, and others to create a binary image out of a grayscale or color one. If mode equals to cv\+::\+R\+E\+T\+R\+\_\+\+C\+C\+O\+MP or cv\+::\+R\+E\+T\+R\+\_\+\+F\+L\+O\+O\+D\+F\+I\+LL, the input can also be a 32-\/bit integer image of labels (C\+V\+\_\+32\+S\+C1). \\
\hline
{\em contours} & Detected contours. Each contour is stored as a vector of points (e.\+g. std\+::vector$<$std\+::vector$<$cv\+::\+fr.antproject.utils.Point$>$ $>$). \\
\hline
{\em hierarchy} & Optional output vector (e.\+g. std\+::vector$<$cv\+::\+Vec4i$>$), containing information about the image topology. It has as many elements as the number of contours. For each i-\/th contour contours\mbox{[}i\mbox{]}, the elements hierarchy\mbox{[}i\mbox{]}\mbox{[}0\mbox{]} , hiearchy\mbox{[}i\mbox{]}\mbox{[}1\mbox{]} , hiearchy\mbox{[}i\mbox{]}\mbox{[}2\mbox{]} , and hiearchy\mbox{[}i\mbox{]}\mbox{[}3\mbox{]} are set to 0-\/based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy\mbox{[}i\mbox{]} will be negative. \\
\hline
{\em mode} & Contour retrieval mode, see cv\+::\+Retrieval\+Modes \\
\hline
{\em method} & Contour approximation method, see cv\+::\+Contour\+Approximation\+Modes \\
\hline
{\em offset} & Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image R\+OI and then they should be analyzed in the whole image context. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga9242b107e02badf32d704830cda84585}\label{group__imgproc__shape_ga9242b107e02badf32d704830cda84585}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!find\+Contours@{find\+Contours}}
\index{find\+Contours@{find\+Contours}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{find\+Contours()}{fr.antproject.utils.findContours()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+find\+Contours (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{image,  }\item[{@By\+Val Mat\+Vector}]{contours,  }\item[{int}]{mode,  }\item[{int}]{method,  }\item[{@By\+Val(null\+Value=\char`\"{}cv\+::\+fr.antproject.utils.Point()\char`\"{}) fr.antproject.utils.Point}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__shape_ga4e705f42eefa1224c87285653b6fb44d}\label{group__imgproc__shape_ga4e705f42eefa1224c87285653b6fb44d}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!fit\+Ellipse@{fit\+Ellipse}}
\index{fit\+Ellipse@{fit\+Ellipse}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{fit\+Ellipse()}{fitEllipse()}}
{\footnotesize\ttfamily static native Rotated\+Rect org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Ellipse (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Fits an ellipse around a set of 2D points. 

The function calculates the ellipse that fits (in a least-\/squares sense) a set of 2D points best of all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by {\bfseries [Fitzgibbon95]} is used. Developer should keep in mind that it is possible that the returned ellipse/rotated\+Rect data contains negative indices, due to the data points being close to the border of the containing Mat element. 


\begin{DoxyParams}{Parameters}
{\em points} & Input 2D point set, stored in std\+::vector$<$$>$ or Mat \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga081f0e410b01a81bbfe62c828ebb3c6f}\label{group__imgproc__shape_ga081f0e410b01a81bbfe62c828ebb3c6f}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!fit\+Line@{fit\+Line}}
\index{fit\+Line@{fit\+Line}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{fit\+Line()}{fitLine()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+fit\+Line (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points,  }\item[{@By\+Val Mat}]{line,  }\item[{int}]{dist\+Type,  }\item[{double}]{param,  }\item[{double}]{reps,  }\item[{double}]{aeps }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Fits a line to a 2D or 3D point set. 

The function fit\+Line fits a line to a 2D or 3D point set by minimizing $\sum_i \rho(r_i)$ where $r_i$ is a distance between the $i^{th}$ point, the line and $\rho(r)$ is a distance function, one of the following\+:
\begin{DoxyItemize}
\item D\+I\+S\+T\+\_\+\+L2 \[\rho (r) = r^2/2 \quad \text{(the simplest and the fastest least-squares method)}\]
\item D\+I\+S\+T\+\_\+\+L1 \[\rho (r) = r\]
\item D\+I\+S\+T\+\_\+\+L12 \[\rho (r) = 2 \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1)\]
\item D\+I\+S\+T\+\_\+\+F\+A\+IR \[\rho \left (r \right ) = C^2 \cdot \left ( \frac{r}{C} - \log{\left(1 + \frac{r}{C}\right)} \right ) \quad \text{where} \quad C=1.3998\]
\item D\+I\+S\+T\+\_\+\+W\+E\+L\+S\+CH \[\rho \left (r \right ) = \frac{C^2}{2} \cdot \left ( 1 - \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right ) \quad \text{where} \quad C=2.9846\]
\item D\+I\+S\+T\+\_\+\+H\+U\+B\+ER \[\rho (r) = \fork{r^2/2}{if \(r < C\)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345\] 
\end{DoxyItemize}

The algorithm is based on the M-\/estimator ( \href{http://en.wikipedia.org/wiki/M-estimator}{\tt http\+://en.\+wikipedia.\+org/wiki/\+M-\/estimator} ) technique that iteratively fits the line using the weighted least-\/squares algorithm. After each iteration the weights $w_i$ are adjusted to be inversely proportional to $\rho(r_i)$ . 


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D or 3D points, stored in std\+::vector$<$$>$ or Mat. \\
\hline
{\em line} & Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) -\/ (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like Vec6f) -\/ (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is a point on the line. \\
\hline
{\em dist\+Type} & Distance used by the M-\/estimator, see cv\+::\+Distance\+Types \\
\hline
{\em param} & Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen. \\
\hline
{\em reps} & Sufficient accuracy for the radius (distance between the coordinate origin and the line). \\
\hline
{\em aeps} & Sufficient accuracy for the angle. 0.\+01 would be a good default value for reps and aeps. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga352b5f00f51966f12301dfd255d06189}\label{group__imgproc__shape_ga352b5f00f51966f12301dfd255d06189}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!Hu\+Moments@{Hu\+Moments}}
\index{Hu\+Moments@{Hu\+Moments}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{Hu\+Moments()}{HuMoments()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments (\begin{DoxyParamCaption}\item[{@Const @By\+Ref Moments}]{moments,  }\item[{Double\+Pointer}]{hu }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Calculates seven Hu invariants. 

The function calculates seven Hu invariants (introduced in {\bfseries [Hu62]}; see also \href{http://en.wikipedia.org/wiki/Image_moment}{\tt http\+://en.\+wikipedia.\+org/wiki/\+Image\+\_\+moment}) defined as\+: 

\[\begin{array}{l} hu[0]= \eta _{20}+ \eta _{02} \\ hu[1]=( \eta _{20}- \eta _{02})^{2}+4 \eta _{11}^{2} \\ hu[2]=( \eta _{30}-3 \eta _{12})^{2}+ (3 \eta _{21}- \eta _{03})^{2} \\ hu[3]=( \eta _{30}+ \eta _{12})^{2}+ ( \eta _{21}+ \eta _{03})^{2} \\ hu[4]=( \eta _{30}-3 \eta _{12})( \eta _{30}+ \eta _{12})[( \eta _{30}+ \eta _{12})^{2}-3( \eta _{21}+ \eta _{03})^{2}]+(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ hu[5]=( \eta _{20}- \eta _{02})[( \eta _{30}+ \eta _{12})^{2}- ( \eta _{21}+ \eta _{03})^{2}]+4 \eta _{11}( \eta _{30}+ \eta _{12})( \eta _{21}+ \eta _{03}) \\ hu[6]=(3 \eta _{21}- \eta _{03})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}]-( \eta _{30}-3 \eta _{12})( \eta _{21}+ \eta _{03})[3( \eta _{30}+ \eta _{12})^{2}-( \eta _{21}+ \eta _{03})^{2}] \\ \end{array}\] 

where $\eta_{ji}$ stands for $\texttt{Moments::nu}_{ji}$ . 

These values are proved to be invariants to the image scale, rotation, and reflection except the seventh one, whose sign is changed by reflection. This invariance is proved with the assumption of infinite image resolution. In case of raster images, the computed Hu invariants for the original and transformed images are a bit different. 


\begin{DoxyParams}{Parameters}
{\em moments} & Input moments computed with moments . \\
\hline
{\em hu} & Output Hu invariants. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\hyperlink{group__imgproc__shape_gad14ba9809a9703bef3dbdcd1a487d2fb}{match\+Shapes} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__imgproc__shape_gab567ad055b6ac17d75b8f78044f7c2d4}\label{group__imgproc__shape_gab567ad055b6ac17d75b8f78044f7c2d4}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!Hu\+Moments@{Hu\+Moments}}
\index{Hu\+Moments@{Hu\+Moments}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{Hu\+Moments()}{HuMoments()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+Hu\+Moments (\begin{DoxyParamCaption}\item[{@Const @By\+Ref Moments}]{m,  }\item[{@By\+Val Mat}]{hu }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \mbox{\Hypertarget{group__imgproc__shape_ga1664076df6a9c8e2780c3650b12551a1}\label{group__imgproc__shape_ga1664076df6a9c8e2780c3650b12551a1}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!intersect\+Convex\+Convex@{intersect\+Convex\+Convex}}
\index{intersect\+Convex\+Convex@{intersect\+Convex\+Convex}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{intersect\+Convex\+Convex()}{intersectConvexConvex()}}
{\footnotesize\ttfamily static native float org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+intersect\+Convex\+Convex (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{\+\_\+p1,  }\item[{@By\+Val Mat}]{\+\_\+p2,  }\item[{@By\+Val Mat}]{\+\_\+p12,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{handle\+Nested }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

finds intersection of two convex polygons \mbox{\Hypertarget{group__imgproc__shape_gad00ac2d87b83a753b5edcdbb2daf526f}\label{group__imgproc__shape_gad00ac2d87b83a753b5edcdbb2daf526f}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!is\+Contour\+Convex@{is\+Contour\+Convex}}
\index{is\+Contour\+Convex@{is\+Contour\+Convex}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{is\+Contour\+Convex()}{isContourConvex()}}
{\footnotesize\ttfamily static native boolean org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+is\+Contour\+Convex (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{contour }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Tests a contour convexity. 

The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-\/intersections. Otherwise, the function output is undefined. 


\begin{DoxyParams}{Parameters}
{\em contour} & Input vector of 2D points, stored in std\+::vector$<$$>$ or Mat \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gad14ba9809a9703bef3dbdcd1a487d2fb}\label{group__imgproc__shape_gad14ba9809a9703bef3dbdcd1a487d2fb}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!match\+Shapes@{match\+Shapes}}
\index{match\+Shapes@{match\+Shapes}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{match\+Shapes()}{matchShapes()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+match\+Shapes (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{contour1,  }\item[{@By\+Val Mat}]{contour2,  }\item[{int}]{method,  }\item[{double}]{parameter }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Compares two shapes. 

The function compares two shapes. All three implemented methods use the Hu invariants (see cv\+::\+Hu\+Moments) 


\begin{DoxyParams}{Parameters}
{\em contour1} & First contour or grayscale image. \\
\hline
{\em contour2} & Second contour or grayscale image. \\
\hline
{\em method} & Comparison method, see \+::\+Shape\+Match\+Modes \\
\hline
{\em parameter} & Method-\/specific parameter (not supported now). \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gae621046d95a8ba9f1e1ce112ab8de61a}\label{group__imgproc__shape_gae621046d95a8ba9f1e1ce112ab8de61a}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!min\+Area\+Rect@{min\+Area\+Rect}}
\index{min\+Area\+Rect@{min\+Area\+Rect}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{min\+Area\+Rect()}{minAreaRect()}}
{\footnotesize\ttfamily static native Rotated\+Rect org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Area\+Rect (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds a rotated rectangle of the minimum area enclosing the input 2D point set. 

The function calculates and returns the minimum-\/area bounding rectangle (possibly rotated) for a specified point set. See the Open\+CV sample minarea.\+cpp . Developer should keep in mind that the returned rotated\+Rect can contain negative indices when data is close to the containing Mat element boundary. 


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D points, stored in std\+::vector$<$$>$ or Mat \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga6247e734952a578322d69260230c4a41}\label{group__imgproc__shape_ga6247e734952a578322d69260230c4a41}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!min\+Enclosing\+Circle@{min\+Enclosing\+Circle}}
\index{min\+Enclosing\+Circle@{min\+Enclosing\+Circle}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{min\+Enclosing\+Circle()}{minEnclosingCircle()}}
{\footnotesize\ttfamily static native void org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Circle (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points,  }\item[{@By\+Ref Point2f}]{center,  }\item[{@By\+Ref Float\+Pointer}]{radius }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds a circle of the minimum area enclosing a 2D point set. 

The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm. See the Open\+CV sample minarea.\+cpp . 


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D points, stored in std\+::vector$<$$>$ or Mat \\
\hline
{\em center} & Output center of the circle. \\
\hline
{\em radius} & Output radius of the circle. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_ga789d0feac6b1ff1a2d13cfc58fa3e898}\label{group__imgproc__shape_ga789d0feac6b1ff1a2d13cfc58fa3e898}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!min\+Enclosing\+Triangle@{min\+Enclosing\+Triangle}}
\index{min\+Enclosing\+Triangle@{min\+Enclosing\+Triangle}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{min\+Enclosing\+Triangle()}{minEnclosingTriangle()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+min\+Enclosing\+Triangle (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{points,  }\item[{@By\+Val Mat}]{triangle }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds a triangle of minimum area enclosing a 2D point set and returns its area. 

The function finds a triangle of minimum area enclosing the given set of 2D points and returns its area. The output for a given 2D point set is shown in the image below. 2D points are depicted in red$\ast$ and the enclosing triangle in {\itshape yellow}. 

 

The implementation of the algorithm is based on O\textquotesingle{}Rourke\textquotesingle{}s {\bfseries [O\+Rourke86]} and Klee and Laskowski\textquotesingle{}s {\bfseries [Klee\+Laskowski85]} papers. O\textquotesingle{}Rourke provides a $\theta(n)$ algorithm for finding the minimal enclosing triangle of a 2D convex polygon with n vertices. Since the min\+Enclosing\+Triangle function takes a 2D point set as input an additional preprocessing step of computing the convex hull of the 2D point set is required. The complexity of the convex\+Hull function is $O(n log(n))$ which is higher than $\theta(n)$. Thus the overall complexity of the function is $O(n log(n))$. 


\begin{DoxyParams}{Parameters}
{\em points} & Input vector of 2D points with depth C\+V\+\_\+32S or C\+V\+\_\+32F, stored in std\+::vector$<$$>$ or Mat \\
\hline
{\em triangle} & Output vector of three 2D points defining the vertices of the triangle. The depth of the Output\+Array must be C\+V\+\_\+32F. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gaf6f02003be04d7a37eff3af25946ff77}\label{group__imgproc__shape_gaf6f02003be04d7a37eff3af25946ff77}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!point\+Polygon\+Test@{point\+Polygon\+Test}}
\index{point\+Polygon\+Test@{point\+Polygon\+Test}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{point\+Polygon\+Test()}{pointPolygonTest()}}
{\footnotesize\ttfamily static native double org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+point\+Polygon\+Test (\begin{DoxyParamCaption}\item[{@By\+Val Mat}]{contour,  }\item[{@By\+Val Point2f}]{pt,  }\item[{@Cast(\char`\"{}bool\char`\"{}) boolean}]{measure\+Dist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Performs a point-\/in-\/contour test. 

The function determines whether the point is inside a contour, outside, or lies on an edge (or coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge) value, correspondingly. When measure\+Dist=false , the return value is +1, -\/1, and 0, respectively. Otherwise, the return value is a signed distance between the point and the nearest contour edge. 

See below a sample output of the function where each image pixel is tested against the contour\+: 

 


\begin{DoxyParams}{Parameters}
{\em contour} & Input contour. \\
\hline
{\em pt} & fr.antproject.utils.Point tested against the contour. \\
\hline
{\em measure\+Dist} & If true, the function estimates the signed distance from the point to the nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{group__imgproc__shape_gadcfa20fed89c804a31f05ae6e1023379}\label{group__imgproc__shape_gadcfa20fed89c804a31f05ae6e1023379}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!rotated\+Rectangle\+Intersection@{rotated\+Rectangle\+Intersection}}
\index{rotated\+Rectangle\+Intersection@{rotated\+Rectangle\+Intersection}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{rotated\+Rectangle\+Intersection()}{rotatedRectangleIntersection()}}
{\footnotesize\ttfamily static native int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+rotated\+Rectangle\+Intersection (\begin{DoxyParamCaption}\item[{@Const @By\+Ref Rotated\+Rect}]{rect1,  }\item[{@Const @By\+Ref Rotated\+Rect}]{rect2,  }\item[{@By\+Val Mat}]{intersecting\+Region }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Finds out if there is any intersection between two rotated rectangles. 

If there is then the vertices of the interesecting region are returned as well. 

Below are some examples of intersection configurations. The hatched pattern indicates the intersecting region and the red vertices are returned by the function. 

 


\begin{DoxyParams}{Parameters}
{\em rect1} & First rectangle \\
\hline
{\em rect2} & Second rectangle \\
\hline
{\em intersecting\+Region} & The output array of the verticies of the intersecting region. It returns at most 8 vertices. Stored as std\+::vector$<$cv\+::\+Point2f$>$ or cv\+::\+Mat as Mx1 of type C\+V\+\_\+32\+F\+C2. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
One of cv\+::\+Rectangles\+Intersect\+Types 
\end{DoxyReturn}


\subsection{Variable Documentation}
\mbox{\Hypertarget{group__imgproc__shape_ga349952fcbf280ca92c36978312c607a6}\label{group__imgproc__shape_ga349952fcbf280ca92c36978312c607a6}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT@{C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT}}
\index{C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT@{C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT}{CC\_STAT\_LEFT}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+C\+\_\+\+S\+T\+A\+T\+\_\+\+L\+E\+FT = 0\hspace{0.3cm}{\ttfamily [static]}}

enum cv\+::\+Connected\+Components\+Types The leftmost (x) coordinate which is the inclusive start of the bounding box in the horizontal direction. \mbox{\Hypertarget{group__imgproc__shape_ga9b0d3771ada15612aef51a25db60c21f}\label{group__imgproc__shape_ga9b0d3771ada15612aef51a25db60c21f}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!C\+C\+L\+\_\+\+WU@{C\+C\+L\+\_\+\+WU}}
\index{C\+C\+L\+\_\+\+WU@{C\+C\+L\+\_\+\+WU}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{C\+C\+L\+\_\+\+WU}{CCL\_WU}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+C\+L\+\_\+\+WU = 0\hspace{0.3cm}{\ttfamily [static]}}

connected components algorithm enum cv\+::\+Connected\+Components\+Algorithms\+Types S\+A\+UF algorithm for 8-\/way connectivity, S\+A\+UF algorithm for 4-\/way connectivity \mbox{\Hypertarget{group__imgproc__shape_ga2e9681fae693a35abe17e8f4265acdbf}\label{group__imgproc__shape_ga2e9681fae693a35abe17e8f4265acdbf}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE@{C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE}}
\index{C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE@{C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE}{CHAIN\_APPROX\_NONE}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+C\+H\+A\+I\+N\+\_\+\+A\+P\+P\+R\+O\+X\+\_\+\+N\+O\+NE = 1\hspace{0.3cm}{\ttfamily [static]}}

the contour approximation algorithm enum cv\+::\+Contour\+Approximation\+Modes stores absolutely all the contour points. That is, any 2 subsequent points (x1,y1) and (x2,y2) of the contour will be either horizontal, vertical or diagonal neighbors, that is, max(abs(x1-\/x2),abs(y2-\/y1))==1. \mbox{\Hypertarget{group__imgproc__shape_gae1ca9924d0a73e52ad45f660cc2160e4}\label{group__imgproc__shape_gae1ca9924d0a73e52ad45f660cc2160e4}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE@{I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE}}
\index{I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE@{I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE}{INTERSECT\_NONE}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+I\+N\+T\+E\+R\+S\+E\+C\+T\+\_\+\+N\+O\+NE = 0\hspace{0.3cm}{\ttfamily [static]}}

types of intersection between rectanglesenum cv\+::\+Rectangles\+Intersect\+Types No intersection \mbox{\Hypertarget{group__imgproc__shape_ga94d7307a24949485303f94d555fd31c8}\label{group__imgproc__shape_ga94d7307a24949485303f94d555fd31c8}} 
\index{Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}!R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL@{R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL}}
\index{R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL@{R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL}!Structural Analysis and Shape Descriptors@{Structural Analysis and Shape Descriptors}}
\subsubsection{\texorpdfstring{R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL}{RETR\_EXTERNAL}}
{\footnotesize\ttfamily final int org.\+bytedeco.\+javacpp.\+opencv\+\_\+imgproc.\+R\+E\+T\+R\+\_\+\+E\+X\+T\+E\+R\+N\+AL = 0\hspace{0.3cm}{\ttfamily [static]}}

mode of the contour retrieval algorithm enum cv\+::\+Retrieval\+Modes retrieves only the extreme outer contours. It sets
\begin{DoxyCode}
hierarchy[i][2]=hierarchy[i][3]=-1 
\end{DoxyCode}
 for all the contours. 